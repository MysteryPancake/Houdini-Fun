<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Time Smoothing</title>
		<meta name="description" content="Various ways to smooth and sharpen in Houdini.">
		<meta name="keywords" content="Lerp, Interpolation, Convolution, Kernel, Lowpass, Highpass, Bandpass, Allpass, Biquad, Filter, Smooth, Sharp">
		<meta property="og:title" content="Time Smoothing">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mysterypancake.github.io/Houdini-Fun/TimeSmoothing">
		<meta property="og:site_name" content="Time Smoothing">
		<meta property="og:description" content="Various ways to smooth and sharpen in Houdini.">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="./scripts/highlight.min.css">
		<script src="./scripts/highlight.min.js"></script>
		<link href="./scripts/bootstrap.min.css" rel="stylesheet">
		<script>
		// This uses requestFrame(), some browsers name it differently so this finds the best alternative
		const requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) { return window.setTimeout(e, 1000 / 60); };
		
		function lerp(a, b, factor) {
			return (1 - factor) * a + factor * b;
		}

		function clamp(x, min, max) {
			return Math.min(Math.max(x, min), max);
		}
		
		function mouseClickData(e, canv, data) {
			const key = Math.min(data.length - 1, e.offsetX / canv.width * data.length);
			data[key] = e.offsetY / canv.height;
		}

		// When drawing, replace entries which were drawn over between frames
		function mouseMoveData(e, canv, data) {
			if (e.which !== 1) return;
			const lastKey = Math.floor((e.offsetX - e.movementX) / canv.width * data.length);
			const currentKey = Math.floor(e.offsetX / canv.width * data.length);
			const start = Math.min(lastKey, currentKey);
			const end = clamp(currentKey, lastKey, data.length - 1);
			for (let i = start; i <= end; ++i) {
				data[i] = e.offsetY / canv.height;
			}
		}
		
		// Structured sine wave data
		function generateData(numPoints) {
			const data = Array(numPoints);
			for (let i = 0; i < numPoints; ++i) {
				const factor = i / numPoints;
				const sin = Math.sin(factor*10)*0.3+0.5;
				const noiseAmount = (Math.cos(factor*15)+1)*0.2;
				const rand = Math.random()-0.5;
				data[i] = sin + rand * noiseAmount;
			}
			return data;
		}

		// Completely random data
		function generateRandomData(numPoints) {
			const data = Array(numPoints);
			for (let i = 0; i < numPoints; ++i) {
				data[i] = Math.random();
			}
			return data;
		}

		function resizeCanvasWidth(elem) {
			elem.width = elem.parentElement.clientWidth;
		}
		</script>
	</head>
	<body>
		<div class="container mt-5">
			<h1 class="mb-3"><span style="filter: blur(3px);">Smoothing</span> <span style="filter: blur(1.5px);">and</span> Sharpening in time</h1>
			<p>This was inspired by a talk <a href="https://www.linkedin.com/feed/update/urn:li:activity:7159079030745452544/" target="_blank">Catherine Williams did at SydHUG</a>. She looked into a bunch of equations to smooth data, then used them to smooth jittery cloth sims over time.</p>
			<p>Smoothing and sharpening is a pretty cool topic I've dipped into into a few times, so I wanted to gather some popular methods and dump them into Houdini in case it helps someone. If you're Catherine this is probably old news, but hopefully it's fun anyway!</p>
			<p>For some reason Houdini doesn't really have built-in nodes for time smoothing. Unreal Engine, Blender and Maya have plenty of ways, like Butterworth and Chebyshev filters. These are super popular for motion capture, which always comes in janky and needs tons of smoothing.</p>
			<p>Since Houdini doesn't have much to work with, let's make it from scratch!</p>
			<h2 class="mb-3">Basic method: Lerp</h2>
			<p>The easiest way to smooth stuff is with lerp, <a href="./Lerp" target="_blank">which I wrote about here</a>. It's really popular for games, especially in Unity. It's not a good method, but it's a nice intro to the topic.</p>
			<p>The idea is you start at some value, then pick a target value. Each frame you move a little bit closer to the target by some percentage. The slower you move, the smoother your path becomes.</p>
			<pre><code class="language-js">current = lerp(current, target, factor);</code></pre>
			<p>Here's a demo with the smooth version in white. Click and drag to draw your own data.</p>
			<div>
				<canvas id="lerpCanvas" width="640" height="256"></canvas>
			</div>
			<div>
				<canvas id="lerpLiveCanvas" width="640" height="32"></canvas>
			</div>
			<div class="mb-3">
				<label for="lerpFactor">Factor</label>
				<input id="lerpFactor" type="range" min="0" max="1" step="0.01" value="0.1">
				<span id="lerpFactorValue"></span>
			</div>
			<script>
			(function(){
				const canv = document.getElementById("lerpCanvas");
				const ctx = canv.getContext("2d", { alpha: false });
				resizeCanvasWidth(canv);

				const lerpSlider = document.getElementById("lerpFactor");
				let lerpFac = parseFloat(lerpSlider.value);

				const lerpValue = document.getElementById("lerpFactorValue");
				lerpValue.textContent = lerpFac;

				const data = generateData(Math.floor(canv.width / 2));
				
				function draw() {
					ctx.fillStyle = "#404040";
					ctx.fillRect(0, 0, canv.width, canv.height);
					
					ctx.lineWidth = 2;
					ctx.strokeStyle = "#DD2020";
					ctx.beginPath();
					for (let i = 0; i < data.length; ++i) {
						ctx.lineTo(i / data.length * canv.width, data[i] * canv.height);
					}
					ctx.stroke();
					
					ctx.strokeStyle = "white";
					ctx.beginPath();
					let current = data[0];
					for (let i = 0; i < data.length; ++i) {
						// The magic formula
						current = lerp(current, data[i], lerpFac);
						ctx.lineTo(i / data.length * canv.width, current * canv.height);
					}
					ctx.stroke();
				}
				
				draw();

				lerpSlider.addEventListener("input", function(e) {
					lerpFac = parseFloat(e.target.value);
					lerpValue.textContent = lerpFac;
					draw();
				});

				canv.addEventListener("click", function(e) {
					mouseClickData(e, canv, data);
					draw();
				});
				
				canv.addEventListener("mousemove", function(e) {
					mouseMoveData(e, canv, data);
					draw();
				});

				const canv2 = document.getElementById("lerpLiveCanvas");
				const ctx2 = canv2.getContext("2d", { alpha: false });
				resizeCanvasWidth(canv2);

				let target = Math.random() * (canv2.width - canv2.height);
				let current = 0;

				function drawLive() {
					ctx2.fillStyle = "#404040";
					ctx2.fillRect(0, 0, canv2.width, canv2.height);

					const blockSize = canv2.height * 0.5;

					// Draw target value
					ctx2.fillStyle = "#FF0000";
					ctx2.fillRect(target, blockSize * 0.5, blockSize, blockSize);

					// Draw current value
					ctx2.fillStyle = "white";
					ctx2.fillRect(current, blockSize * 0.5, blockSize, blockSize);

					// The magic formula
					current = lerp(current, target, lerpFac);

					requestFrame(drawLive);
				}

				requestFrame(drawLive);

				let hovering = false;

				canv2.addEventListener("mouseenter", function(e) {
					hovering = true;
				});

				canv2.addEventListener("mouseleave", function(e) {
					hovering = false;
				});

				// Move target to new position
				window.setInterval(function() {
					if (hovering) return;
					target = Math.random() * (canv2.width - canv2.height);
				}, 1000);

				canv2.addEventListener("mousemove", function(e) {
					target = e.offsetX;
				});
			})();
			</script>
			<p>There's 3 big problems with this method, which all smoothing methods suffer from.</p>
			<h3 class="mb-3">Problem 1. Phase shift</h3>
			<p>If you set the slider really low, it looks like the graph moves to the right. This is called <b>phase shift</b>.</p>
			<p>It happens since the value is too lazy in moving to the target, so it sticks near the previous value and smears out the graph.</p>
			<p>Phase shift is a popular topic in music, you'll find many audio engineers rambling about it online (<a href="https://www.youtube.com/@DanWorrall" target="_blank">Dan Worrall</a> is my favourite). When you use an equalizer on music (for example to boost the bass), it usually adds a bit of phase shift. Some plugins (like <a href="https://ddmf.eu/plugindoctor/" target="_blank">Plugindoctor</a>) even show you the exact phase shift you'll get. This is called the <b>phase response</b>.</p>
			<p>Phase shift is a natural part of the universe so there's nothing wrong with it, but it's annoying if you want stuff to line up. The lazy way is shifting over the graph. The proper way is using <b>linear phase</b> filters. Linear phase filters always need values forwards in time as well as backwards.</p>
			<p>Apparently if you <a href="https://www.youtube.com/watch?v=eSyCuuSzuE4" target="_blank">smooth forwards then again in reverse</a>, it cancels out the phase shift and makes a linear phase filter. Here's a demo with the linear version in green.</p>
			<div>
				<canvas id="lerp3Canvas" width="640" height="256"></canvas>
			</div>
			<div class="mb-3">
				<label for="lerp3Factor">Factor</label>
				<input id="lerp3Factor" type="range" min="0" max="1" step="0.01" value="0.02">
				<span id="lerp3FactorValue"></span>
			</div>
			<script>
			(function(){
				const canv = document.getElementById("lerp3Canvas");
				const ctx = canv.getContext("2d", { alpha: false });
				resizeCanvasWidth(canv);

				const lerpSlider = document.getElementById("lerp3Factor");
				let lerpFac = parseFloat(lerpSlider.value);

				const lerpValue = document.getElementById("lerp3FactorValue");
				lerpValue.textContent = lerpFac;

				const data = generateData(Math.floor(canv.width / 2));
				
				function draw() {
					ctx.fillStyle = "#404040";
					ctx.fillRect(0, 0, canv.width, canv.height);
					
					ctx.lineWidth = 2;
					ctx.strokeStyle = "#808080";
					ctx.beginPath();
					for (let i = 0; i < data.length; ++i) {
						ctx.lineTo(i / data.length * canv.width, data[i] * canv.height);
					}
					ctx.stroke();
					
					ctx.strokeStyle = "#FF0000";
					ctx.beginPath();

					// Smooth forwards in time
					const dataCopy = data.slice();
					let current = dataCopy[0];
					for (let i = 0; i < dataCopy.length; ++i) {
						// The magic formula
						current = lerp(current, dataCopy[i], lerpFac);
						ctx.lineTo(i / dataCopy.length * canv.width, current * canv.height);
						dataCopy[i] = current;
					}

					ctx.stroke();

					ctx.strokeStyle = "#00FF00";
					ctx.beginPath();

					// Smooth backwards in time
					current = dataCopy[dataCopy.length - 1];
					for (let i = dataCopy.length - 1; i >= 0; --i) {
						// The magic formula
						current = lerp(current, dataCopy[i], lerpFac);
						ctx.lineTo(i / dataCopy.length * canv.width, current * canv.height);
					}

					ctx.stroke();
				}
				
				draw();

				lerpSlider.addEventListener("input", function(e) {
					lerpFac = parseFloat(e.target.value);
					lerpValue.textContent = lerpFac;
					draw();
				});

				canv.addEventListener("click", function(e) {
					mouseClickData(e, canv, data);
					draw();
				});
				
				canv.addEventListener("mousemove", function(e) {
					mouseMoveData(e, canv, data);
					draw();
				});
			})();
			</script>

			<h3 class="mb-3">Problem 2. Oversmoothing</h3>
			<p>You'll find this method is hard to control. It tends to smooth everything too much or not enough.</p>
			<p>This is because of the <b>order</b> of the filter. The order basically means how sharp and precise a filter is. Here's a nice diagram from <a href="https://www.electronics-tutorials.ws/filter/filter_8.html" target="_blank">Electronics Tutorials</a>. You can see as the order increases the curve gets steeper, meaning it cuts precisely and doesn't smudge everything.</p>
			<img src="./images/smoothing/filterorder.gif" class="mb-3">
			<p>The lerp method is a <a href="https://ccrma.stanford.edu/~jos/fp/Definition_Simplest_Low_Pass.html" target="_blank">first order lowpass</a>, so it's pretty blunt and tends to smudge everything out.</p>
			<p>Turns out there's a cool trick to improve it. If you stack a bunch of low order filters, you approximate a high order filter. This works surprisingly well, though it's much slower and smudgier than doing it properly.</p>
			<p>Here's a demo with the original filter in red, and the layered filters coloured towards purple. Try drawing some data and watch it move!</p>
			<canvas id="lerp2Canvas" width="640" height="256"></canvas>
			<table class="mb-3">
				<tr>
					<td style="width: 220px;">
						<label for="lerp2Factor">Factor</label>
						<input id="lerp2Factor" type="range" min="0" max="1" step="0.01" value="0.1">
						<span id="lerp2FactorValue"></span>
					</td>
					<td style="width: 220px;">
						<label for="lerp2Layers">Layers</label>
						<input id="lerp2Layers" type="range" min="1" max="50" step="1" value="10">
						<span id="lerp2LayersValue"></span>
					</td>
					<td style="width: 220px;">
						<input id="lerp2Linear" type="checkbox">
						<label for="lerp2Linear">Linear Phase</label>
					</td>
				</tr>
			</table>
			<script>
			(function(){
				const canv = document.getElementById("lerp2Canvas");
				const ctx = canv.getContext("2d", { alpha: false });
				resizeCanvasWidth(canv);

				const lerpSlider = document.getElementById("lerp2Factor");
				let lerpFac = parseFloat(lerpSlider.value);

				const lerpValue = document.getElementById("lerp2FactorValue");
				lerpValue.textContent = lerpFac;

				const layersSlider = document.getElementById("lerp2Layers");
				let lerpLayers = parseFloat(layersSlider.value);

				const layersValue = document.getElementById("lerp2LayersValue");
				layersValue.textContent = lerpLayers;

				const linearToggle = document.getElementById("lerp2Linear");
				let linearPhase = linearToggle.checked;

				const data = generateData(Math.floor(canv.width / 2));
				
				function draw() {
					ctx.fillStyle = "#404040";
					ctx.fillRect(0, 0, canv.width, canv.height);
					
					ctx.lineWidth = 2;
					ctx.strokeStyle = "#808080";
					ctx.beginPath();
					for (let i = 0; i < data.length; ++i) {
						ctx.lineTo(i / data.length * canv.width, data[i] * canv.height);
					}
					ctx.stroke();

					// Chain the crappy lowpass filter to approximate a higher order lowpass filter
					const dataCopy = data.slice();
					for (let j = 0; j < lerpLayers; ++j) {

						ctx.strokeStyle = `hsl(${j / lerpLayers * 360}, 100%, 70%)`;
						ctx.beginPath();

						// Lerp forwards in time
						let current = dataCopy[0];
						for (let i = 0; i < dataCopy.length; ++i) {
							// The magic formula
							current = lerp(current, dataCopy[i], lerpFac);
							if (!linearPhase) {
								ctx.lineTo(i / dataCopy.length * canv.width, current * canv.height);
							}
							dataCopy[i] = current;
						}

						// Lerp backwards in time
						if (linearPhase) {
							current = dataCopy[dataCopy.length - 1];
							for (let i = dataCopy.length - 1; i >= 0; --i) {
								// The magic formula
								current = lerp(current, dataCopy[i], lerpFac);
								ctx.lineTo(i / dataCopy.length * canv.width, current * canv.height);
								dataCopy[i] = current;
							}
						}
						ctx.stroke();
					}
				}
				
				draw();
				
				lerpSlider.addEventListener("input", function(e) {
					lerpFac = parseFloat(e.target.value);
					lerpValue.textContent = lerpFac;
					draw();
				});
				
				layersSlider.addEventListener("input", function(e) {
					lerpLayers = parseFloat(e.target.value);
					layersValue.textContent = lerpLayers;
					draw();
				});

				linearToggle.addEventListener("input", function(e) {
					linearPhase = e.target.checked;
					draw();
				});

				canv.addEventListener("click", function(e) {
					mouseClickData(e, canv, data);
					draw();
				});
				
				canv.addEventListener("mousemove", function(e) {
					mouseMoveData(e, canv, data);
					draw();
				});
			})();
			</script>
			<h3 class="mb-3">Problem 3. Undershooting</h3>
			<p>When the slider is below 1, it never actually reaches the target.</p>
			<p>You can tell from the formula. Lerp takes a percentage of two values and adds them together <a href="./Lerp" target="_blank">as described here</a>. For example if the factor is 0.9, it takes 10% of the current value and adds on 90% of the target value. That means you never get 100% of the target.</p>
			<p>Here's a demo where the white line targets the red line. Though it may appear to, it always lies below the red line until the factor is 1.</p>
			<canvas id="undershootCanvas" width="640" height="256"></canvas>
			<div class="mb-3">
				<label for="undershootFactor">Factor</label>
				<input id="undershootFactor" type="range" min="0" max="1" step="0.01" value="0.1">
				<span id="undershootFactorValue"></span>
			</div>
			<script>
			(function(){
				const canv = document.getElementById("undershootCanvas");
				const ctx = canv.getContext("2d", { alpha: false });
				resizeCanvasWidth(canv);

				const lerpSlider = document.getElementById("undershootFactor");
				let lerpFac = parseFloat(lerpSlider.value);

				const lerpValue = document.getElementById("undershootFactorValue");
				lerpValue.textContent = lerpFac;
				
				function draw() {
					ctx.fillStyle = "#404040";
					ctx.fillRect(0, 0, canv.width, canv.height);
					
					ctx.lineWidth = 2;
					ctx.strokeStyle = "#FF0000";
					ctx.beginPath();
					ctx.moveTo(0, canv.height * 0.2);
					ctx.lineTo(canv.width, canv.height * 0.2);
					ctx.stroke();
					
					ctx.strokeStyle = "white";
					ctx.beginPath();
					let current = 0.8;
					for (let i = 0; i <= canv.width; i += 8) {
						// The magic formula
						current = lerp(current, 0.2, lerpFac);
						ctx.lineTo(i, current * canv.height);
					}
					ctx.stroke();
				}
				
				draw();
				
				lerpSlider.addEventListener("input", function(e) {
					lerpFac = parseFloat(e.target.value);
					lerpValue.textContent = lerpFac;
					draw();
				});
			})();
			</script>
			<p>After writing this I realise undershooting isn't a huge issue, but I'll keep this section anyway.</p>
			<h3 class="mb-3">Running this in Houdini</h3>
			<p>To use this method in Houdini, we need a way to access the previous frame. Luckily there's many ways to do this.</p>
			<h4 class="mb-3">Option 1: Solver</h4>
			<p>I prefer using a Solver since it's the most robust. It runs in sequence so it's guaranteed not to skip any frames, so if you had a huge jolt it continues smoothing out the impact 1000 frames later. Audio plugins also run in sequence, so we can steal their code and be sure the result is the same. This comes in handy later!</p>
			<p>First add a Solver node, then a Point Wrangle inside. Plug the the current animation (Input_1) into the second wrangle input.</p>
			<img src="./images/smoothing/lerpwrangle.PNG" width="640" class="mb-3">
			<p>Now we can write the formula in VEX. In solvers, <code>@P</code> is the current position. The second input we connected <code>@opinput1_P</code> is the latest animation, which is our target position.</p>
			<pre><code class="language-js">v@P = lerp(v@P, v@opinput1_P, chf("factor"));</code></pre>
			<img src="./images/smoothing/lerpsmoothsolver.gif" width="640">
			<p>
				<a href="./hips/smoothing/lerpsmoothsolver.hipnc?raw=true" target="_blank">Download the HIP file!</a>
			</p>
			<p>Although solvers are more robust, to get linear phase or stack filters you have to chain a bunch of solvers in a row. We can avoid this with Trail.</p>
			<h4 class="mb-3">Option 2: Trail</h4>
			<p>Instead of sampling all past frames, it's faster to sample a handful of past frames and try to guess the future from them. This is called a <b>sliding window</b> technique, which Catherine used for her demo. It's good for production since it can be batch processed and run in parallel. <a href="https://www.shadertoy.com/view/dtlSWH" target="_blank">I used it to make a GPU equalizer</a>. However it's inaccurate for lerp-based smoothing, since it ignores jolts if it has no idea they happened.</p>
			<p>To use it, add a Trail node and a Point Wrangle. Plug the trail into the second wrangle input.</p>
			<img src="./images/smoothing/trailwrangle.PNG" width="640" class="mb-3">
			<p>Now we need to extract positions from different frames. This is done using <code>point()</code>. It has 3 arguments, but we only care about the last one.</p>
			<pre><code class="language-js">vector pos = point(0, "P", point_number);</code></pre>
			<p>Given the current point number <code>@ptnum</code>, we need to find the matching point number on the previous frame. Assuming the topology stays the same, you'll find a pattern. Let's say your <code>@ptnum</code> is 0. If the mesh has 5 points, your <code>@ptnum</code> on the previous frame will be 5, 10, 15, 20 and so on. This happens since the Trail node merges batches of 5 points per frame.</p>
			<p>Using <code>npoints(0)</code> to get the number of points in the mesh, the general formula is <code>@ptnum + npoints(0) * frame</code></p>
			<img src="./images/smoothing/trailframes.png" class="mb-3 w-100">
			<p>Using this idea we can lerp through the positions from past to present, just like with the solver. No dictionaries or maps required!</p>
			<pre><code class="language-js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);

// Start at the last frame's position (the oldest frame)
v@P = point(1, "P", i@ptnum + point_count * (trail_length - 1));

// Lerp from the past to the present, like the solver except manually
for (int frame = 1; frame &lt; trail_length; ++frame) {
	// Get the corresponding point position on the next frame
	vector target_pos = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
	// The magic formula
	v@P = lerp(v@P, target_pos, chf("factor"));
}</code></pre>
			<img src="./images/smoothing/lerpsmoothtrail.gif" width="640">
			<p>
				<a href="./hips/smoothing/lerpsmoothtrail.hipnc?raw=true" target="_blank">Download the HIP file!</a>
			</p>
			<p>Sadly this version suffers from phase shift, just like the solver. The great thing with Trail is it doesn't have to. We can make linear phase filters and stack them too!</p>
			<p>First we need a way to get frames forwards in time as well as backwards. This is as easy as adding a Time Shift node after Trail.</p>
			<img src="./images/smoothing/trailtimeshift.png" width="640" class="mb-3">
			<p>Set the frame offset to <code>$F + ch("../trail1/length") / 2 - 1</code>. This centers the current frame, so we have the same number of frames forwards and backwards in time.</p>
			<img src="./images/smoothing/trailframeoffset.png" width="860" class="mb-3">
			<p>Next we can reuse the same frame offset idea from before, except this time filtering in both directions.</p>
			<pre><code class="language-js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);
float factor = chf("factor");
int layers = chi("layers");

// Make an array of all positions on all frames
// For optimization, you could do a forward lerp in here
vector pos[];
resize(pos, trail_length);
for (int frame = 0; frame < trail_length; ++frame) {
	pos[frame] = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
}

// Smooth a bunch of times in a row (if you want)
for (int i = 0; i < layers; ++i) {

	// Smooth forwards in time
	vector current_pos = pos[0];
	for (int frame = 1; frame < trail_length; ++frame) {
		// The magic formula
		pos[frame] = lerp(current_pos, pos[frame], factor);
		current_pos = pos[frame];
	}

	// Smooth backwards in time
	current_pos = pos[trail_length - 1];
	for (int frame = trail_length - 2; frame >= 0; --frame) {
		// The magic formula
		pos[frame] = lerp(current_pos, pos[frame], factor);
		current_pos = pos[frame];
	}
}

// Get the center frame, which is our frame
v@P = pos[trail_length / 2];</code></pre>
			<p>Thanks to looking into the future, we can anticipate motion before it even happens. Here's a demo with the linear phase version in green and the original version in red.</p>
			<img src="./images/smoothing/lerpsmoothtraillinear.gif" width="540">
			<p>
				<a href="./hips/smoothing/lerpsmoothtraillinear.hipnc?raw=true" target="_blank">Download the HIP file!</a>
			</p>
			<p>While lerp works OK, there's plenty of fancier methods of smoothing out stuff. Let's try gaussian blur with convolution!</p>
			<h2 class="mb-3">Fancier method: Convolution</h2>
			<p>Convolution solves many problems we were having before. It's practically linear phase and only needs a handful of frames, making it perfect for batch processing. It's a weighted sum just like lerp, but it's much more powerful than you'd expect. It works for smoothing, sharpening, embossing and all kinds of cool filters.</p>
			<p>It works by picking a value, sampling the neighbours around it, multiplying them and adding them together. It's just like what we did before, except now we have precise control over how much each neighbour contributes to the final result. We can totally ignore neighbours or even flip their influence.</p>
			<p>For example, say you want each value to be the average of its 2 neighbours. For that you can use the kernel <code>[0.5, 0, 0.5]</code>.</p>
			<img src="./images/smoothing/convolution.png" width="640" class="mb-3">
			<p>Here we sample 9's neighbours (4 and 5), then calculate <code>4 * 0.5 + 9 * 0 + 6 * 0.5 = 5</code>. In other words, ignore 9 and average 4 and 6 together.</p>
			<p>The key idea of convolution is you can slide the kernel up and down. Click and drag to see what I mean!</p>
			<div>
				<canvas id="convCanvas" width="720" height="360"></canvas>
			</div>
			<b>Kernel weights</b>
			<table class="mb-3">
				<tr>
					<td style="width: 180px;">
						<input id="convXWeight" type="range" min="0" max="1" step="0.1" value="0.5">
						<span id="convXWeightValue"></span>
					</td>
					<td style="width: 180px;">
						<input id="convYWeight" type="range" min="0" max="1" step="0.1" value="0">
						<span id="convYWeightValue"></span>
					</td>
					<td style="width: 180px;">
						<input id="convZWeight" type="range" min="0" max="1" step="0.1" value="0.5">
						<span id="convZWeightValue"></span>
					</td>
					<td style="width: 180px;">
						<input id="convAll" type="checkbox">
				<label for="convAll">Convolve All</label>
					</td>
				</tr>
			</table>
			<script>
			(function(){
				const canv = document.getElementById("convCanvas");
				const ctx = canv.getContext("2d", { alpha: false });
				resizeCanvasWidth(canv);

				const xSlider = document.getElementById("convXWeight");
				let xWeight = parseFloat(xSlider.value);

				const xValue = document.getElementById("convXWeightValue");
				xValue.textContent = xWeight;

				const ySlider = document.getElementById("convYWeight");
				let yWeight = parseFloat(ySlider.value);

				const yValue = document.getElementById("convYWeightValue");
				yValue.textContent = yWeight;

				const zSlider = document.getElementById("convZWeight");
				let zWeight = parseFloat(zSlider.value);

				const zValue = document.getElementById("convZWeightValue");
				zValue.textContent = zWeight;

				const convToggle = document.getElementById("convAll");
				let convAll = convToggle.checked;

				const data = generateRandomData(Math.floor(canv.width / 16));
				let kernelPos = Math.floor(data.length / 2);

				function draw() {
					ctx.fillStyle = "#404040";
					ctx.fillRect(0, 0, canv.width, canv.height);

					const weights = [xWeight, yWeight, zWeight];
					const columnWidth = canv.width / (data.length - 1);
					const heightSplit = canv.height / 3;

					ctx.fillStyle = "#606060";
					ctx.fillRect((kernelPos - 1) / (data.length - 1) * canv.width, 0, columnWidth * 3, canv.height)

					for (let i = 0; i < data.length; ++i) {
						const xPos = i / (data.length - 1) * canv.width;

						if (convAll || kernelPos === i) {
							let heightSum = canv.height;
							for (let j = 0; j < weights.length; ++j) {
								const height = data[clamp(i - j + 1, 0, data.length)] * weights[j] * heightSplit * 0.5;
								heightSum -= height;
								ctx.fillStyle = `hsl(${(i - j + 1) * 64}, 100%, 70%)`;
								ctx.fillRect(xPos, heightSum, columnWidth, height);
							}
						}

						const height = data[i] * heightSplit * 0.5;
						ctx.fillStyle = `hsl(${i * 64}, 100%, 70%)`;
						ctx.fillRect(xPos, canv.height - heightSplit * 2 - height, columnWidth, height);

						const offset = kernelPos - i;
						if (Math.abs(offset) <= 1) {
							const height2 = data[i] * weights[offset + 1] * heightSplit * 0.5;
							ctx.fillRect(xPos, canv.height - heightSplit - height2, columnWidth, height2);
						}
					}
				}

				draw();

				xSlider.addEventListener("input", function(e) {
					xWeight = parseFloat(e.target.value);
					xValue.textContent = xWeight;
					draw();
				});

				ySlider.addEventListener("input", function(e) {
					yWeight = parseFloat(e.target.value);
					yValue.textContent = yWeight;
					draw();
				});

				zSlider.addEventListener("input", function(e) {
					zWeight = parseFloat(e.target.value);
					zValue.textContent = zWeight;
					draw();
				});

				convToggle.addEventListener("input", function(e) {
					convAll = e.target.checked;
					draw();
				});

				function moveKernel(e) {
					kernelPos = Math.floor(e.offsetX / canv.width * (data.length - 1));
					draw();
				}

				canv.addEventListener("click", moveKernel);
				canv.addEventListener("mousemove", function(e) {
					if (e.which !== 1) return;
					moveKernel(e);
				});
			})();
			</script>
			<p>Tick "Convolve All" to see a full convolution, then mess with the kernel weights to see what you find! Here's a few you can try:</p>
			<ul>
				<li>The kernel <code>[1, 0, 0]</code> shifts everything 1 unit to the left.</li>
				<li>The kernel <code>[0, 0, 1]</code> shifts everything 1 unit to the right.</li>
				<li>The kernel <code>[0, 1, 0]</code> keeps everything the same.</li>
				<li>The kernel <code>[1, 1, 1]</code> sums all 3 values together.</li>
				<li>The kernel <code>[1, 1, 0]</code> sums the previous and current value.</li>
				<li>The kernel <code>[0, 1, 1]</code> sums the current and next value.</li>
				<li>The kernel <code>[1, 0, 1]</code> sums both neighbours.</li>
				<li>The kernel <code>[0.5, 0, 0.5]</code> averages the two neighbours together.</li>
				<li>The kernel <code>[0.5, 0.5, 0]</code> averages the previous and current value.</li>
				<li>The kernel <code>[0, 0.5, 0.5]</code> averages the current and next value.</li>
			</ul>
			<p>With such a small kernel, we can already do so many things. Hopefully this gives an idea of how powerful and versatile convolution can be.</p>
			<p>TODO: GAUSSIAN BLUR</p>
			<h2 class="mb-3">Cool method: Biquad filters</h2>
			<p>TODO: biquad filters</p>
		</div>
		<script>hljs.highlightAll();</script>
	</body>
</html>