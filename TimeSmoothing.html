<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Time Smoothing</title>
		<meta name="description" content="Various ways to smooth and sharpen in Houdini.">
		<meta name="keywords" content="Lerp, Interpolation, Convolution, Kernel, Lowpass, Highpass, Bandpass, Allpass, Biquad, Filter, Smooth, Sharp">
		<meta property="og:title" content="Time Smoothing">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mysterypancake.github.io/Houdini-Fun/TimeSmoothing">
		<meta property="og:site_name" content="Time Smoothing">
		<meta property="og:description" content="Various ways to smooth and sharpen in Houdini.">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="./scripts/highlight.min.css">
		<script src="./scripts/highlight.min.js"></script>
		<link href="./scripts/bootstrap.min.css" rel="stylesheet">
		<link href="./scripts/bootstrap-icons.min.css" rel="stylesheet">
		<script>
		// This uses requestFrame(), some browsers name it differently so this finds the best alternative
		const requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) { return window.setTimeout(e, 1000 / 60); };
		
		function lerp(a, b, factor) {
			return (1 - factor) * a + factor * b;
		}
		
		function invlerp(a, min, max) {
			return (a - min) / (max - min);
		}

		function clamp(x, min, max) {
			return Math.min(Math.max(x, min), max);
		}
		
		function gainTodB(gain) {
			// Clamp to prevent 0 gain
			gain = Math.max(gain, Number.MIN_VALUE);
			return 20.0 * Math.log10(gain);
		}

		function dbToGain(db) {
			return Math.pow(10.0, db / 20.0);
		}
		
		function mouseClickData(e, canv, data, scale) {
			const key = Math.floor(e.offsetX / canv.width * (data.length - 1));
			data[key] = (0.5 - e.offsetY / canv.height) / scale;
		}

		// When drawing, replace entries which were drawn over between frames
		function mouseMoveData(e, canv, data, scale) {
			const lastKey = Math.floor((e.offsetX - e.movementX) / canv.width * (data.length - 1));
			const currentKey = Math.floor(e.offsetX / canv.width * (data.length - 1));
			
			const start = Math.min(lastKey, currentKey);
			const end = clamp(currentKey, lastKey, data.length - 1);
			
			for (let i = start; i <= end; ++i) {
				const pastValue = (e.offsetY + e.movementY * Math.sign(e.movementX));
				const line = start === end ? e.offsetY : lerp(e.offsetY, pastValue, invlerp(i, start, end));
				data[i] = (0.5 - line / canv.height) / scale;
			}
		}
		
		// Structured sine wave data
		function generateData(numPoints) {
			const data = new Float32Array(numPoints);
			for (let i = 0; i < numPoints; ++i) {
				const factor = i / numPoints;
				const sin = Math.sin(factor * 10) * 0.3;
				const noiseAmount = (Math.cos(factor * 15) + 1) * 0.2;
				const rand = Math.random() - 0.5;
				data[i] = sin + rand * noiseAmount;
			}
			return data;
		}
		
		// Completely random data
		function generateRandomData(numPoints) {
			const data = new Float32Array(numPoints);
			for (let i = 0; i < numPoints; ++i) {
				data[i] = Math.random();
			}
			return data;
		}

		// Gaussian kernel, not optimized for symmetry
		function gaussianKernel(numPoints) {
			// Dividing by 3 seems to scale the kernel the best
			let size = numPoints / 3;
			size *= size;

			let sum = 0;
			const kernel = new Float32Array(numPoints);
			const center = (numPoints - 1) * 0.5;

			for (let i = 0; i < numPoints; i++) {
				const x = i - center;
				kernel[i] = Math.exp(-x * x / size);
				sum += kernel[i];
			}

			// Normalize manually, no need for sqrt
			for (let i = 0; i < numPoints; i++) {
				kernel[i] /= sum;
			}
			return kernel;
		}

		function resizeCanvasWidth(elem) {
			elem.width = elem.parentElement.clientWidth;
		}

		function drawBackground(canv, ctx) {
			ctx.fillStyle = "#404040";
			ctx.fillRect(0, 0, canv.width, canv.height);
		}
		
		function drawLine(canv, ctx, x1, y1, x2, y2) {
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();
		}

		function drawConvolution(canv, ctx, data, kernelPos, weights, convAll) {
			const columnWidth = canv.width / (data.length - 1);
			const heightSplit = canv.height / 3;
			const middleWeight = Math.floor(weights.length * 0.5);

			ctx.fillStyle = "#505050";
			ctx.fillRect(kernelPos / (data.length - 1) * canv.width, 0, columnWidth * weights.length, canv.height)

			for (let i = 0; i < data.length; ++i) {
				const xPos = i / (data.length - 1) * canv.width;
				const height = data[i] * heightSplit * 0.5;

				// Draw top bars
				const topColor = `hsl(${i * 64}, 100%, 70%)`;
				ctx.fillStyle = topColor;
				ctx.fillRect(xPos, canv.height - heightSplit * 2 - height, columnWidth, height);

				// Draw middle bars
				ctx.fillStyle = "white";
				const offset = i - kernelPos;
				if (offset >= 0 && offset < weights.length) {
					ctx.fillStyle = "#707070";
					const height2 = weights[offset] * heightSplit * 0.5;
					ctx.fillRect(xPos, canv.height - heightSplit - height2, columnWidth, height2);

					ctx.fillStyle = topColor;
					const height3 = height2 * data[i];
					ctx.fillRect(xPos, canv.height - heightSplit - height3, columnWidth, height3);
				}

				// Draw bottom bars
				if (convAll || kernelPos + middleWeight === i) {
					let heightSum = canv.height;
					for (let j = 0; j < weights.length; ++j) {
						const height = data[clamp(i + j - middleWeight, 0, data.length - 1)] * weights[j] * heightSplit * 0.5;
						heightSum -= height;
						ctx.fillStyle = `hsl(${(i + j - middleWeight) * 64}, 100%, 70%)`;
						ctx.fillRect(xPos, heightSum, columnWidth, height);
					}
				}
			}
		}

		function drawData(canv, ctx, data, scale) {
			ctx.beginPath();
			for (let i = 0; i < data.length; ++i) {
				ctx.lineTo(i / (data.length - 1) * canv.width, (0.5 - data[i] * scale) * canv.height);
			}
			ctx.stroke();
		}

		function setup() {
			let list = document.getElementById("toc");
			const content = document.getElementById("content");
			const headings = content.querySelectorAll('h1, h2, h3, h4, h5, h6');
			const hash = window.location.hash.slice(1);
			let lastLevel = 0;
			let headingItems = [];
			
			headings.forEach(function(heading, index) {
				const level = parseInt(heading.tagName.slice(1));
				if (index === 0) {
					// First element, make a new list
					const childList = document.createElement("ul");
					list.appendChild(childList);
					list = childList;
				} else if (level > lastLevel) {
					// More indentation, make a new list per level
					for (let i = 0; i < level - lastLevel; ++i) {
						const childList = document.createElement("ul");
						list.appendChild(childList);
						list = childList;
					}
				} else if (level < lastLevel) {
					// Less indentation, move back a few levels
					for (let i = 0; i < lastLevel - level; ++i) {
						list = list.parentNode;
					}
				}
				
				let ref = `toc${index}`;
				if (heading.hasAttribute("id")) {
					ref = heading.getAttribute("id");
				} else {
					heading.setAttribute("id", ref);
				}
				
				const item = document.createElement("li");
				
				const link = document.createElement("a");
				link.setAttribute("href", `#${ref}`);
				link.textContent = heading.textContent;
				item.appendChild(link);
				
				list.appendChild(item);
				lastLevel = level;
				headingItems.push({ "link": link, "header": heading });

				// Scroll to linked heading
				if (ref === hash) {
					heading.scrollIntoView(true);
				}
			});
			
			const blurry = document.getElementById("blurryTitle");
			const title = blurry.textContent;
			blurry.textContent = "";
			
			const blurryLetters = [];
			for (let i = 0; i < title.length; ++i) {
				const span = document.createElement("span");
				span.textContent = title.charAt(i);
				const blurPixels = 4 - (i / title.length) * 4;
				span.style = `filter: blur(${blurPixels}px);`;
				blurry.appendChild(span);
				blurryLetters.push(span);
			}
			
			const intro = document.getElementById("intro");
			intro.addEventListener("mousemove", function(e) {
				for (let i = 0; i < blurryLetters.length; ++i) {
					const letter = blurryLetters[i];
					const bounds = letter.getBoundingClientRect();
					const blurPixels = Math.abs(bounds.x - e.clientX) * 0.01;
					letter.style = `filter: blur(${blurPixels}px);`;
				}
			});
			
			function updateNavigation() {
				let latestElem;
				headingItems.forEach(function(item) {
					item.link.classList.remove("active");
					if (item.header.getBoundingClientRect().top < 40) {
						latestElem = item;
					}
				});
				if (latestElem) {
					latestElem.link.classList.add("active");
				}
			}
			
			if (window.innerWidth >= 768) {
				window.addEventListener("scroll", updateNavigation);
				updateNavigation();
			}
			
			hljs.highlightAll();
		}
		</script>
		<style>
		#toc li a {
			color: black;
			display: block;
			text-decoration: none;
			transition: font-weight, padding 0.05s linear;
			width: 100%;
		}
		
		#toc li a:hover, #toc li a.active {
			padding-left: 0.5rem;
		}
		
		#toc li a.active {
			font-weight: bold;
			border-left: 2px solid black;
		}
		
		#toc ul {
			padding-left: 1rem;
			list-style-type: none;
		}
		
		#toc li {
			padding: 0.2rem 0rem;
		}
		
		#toc a.active {
			font-weight: bold;
		}

		h2, h3, h4, h5, h6 {
			margin-top: 1.5rem;
			margin-bottom: 1rem;
		}
		
		.biquad-filter > div, .biquad-filter select, .biquad-filter input {
			width: 100%;
		}

		.biquad-filter {
			background-color: #404040;
			column-gap: 1rem;
			row-gap: 0.5rem;
			padding: 1.2rem;
		}

		.biquad-filter select {
			border-radius: 0.5rem;
			padding: 0.2rem;
		}

		/* Prevent annoying selection issues */
		div:has(> input) {
			user-select: none;
		}
		</style>
	</head>
	<body onload="setup();">
		<div class="container mt-5">
			<div class="row">
				<div class="col-md-3 d-none d-md-block">
					<nav id="toc" class="sticky-top pt-3"></nav>
				</div>
				<div class="col-md-9">
					<section id="intro">
						<h1 id="blurryTitle" class="mb-4">Smoothing and sharpening in time</h1>
						<p>This was inspired by a talk <a href="https://www.linkedin.com/feed/update/urn:li:activity:7159079030745452544/" target="_blank">Catherine Williams did at SydHUG</a>. Catherine looked into a bunch of equations to smooth data, then used them to smooth jittery cloth sims over time.</p>
						<p>Smoothing and sharpening is a cool topic I've dipped into into a few times, so I gathered my favourite methods and dumped them into Houdini in case it helps someone. If you're Catherine this is probably old news, but hopefully it's fun anyway!</p>
						<p>Unreal Engine, Blender and Maya have plenty of smoothing tools, like Butterworth and Chebyshev filters. These are super popular for motion capture, which always comes in janky. Houdini has tools as well, but they're harder to find. Matt Estela mentioned the <a href="https://www.sidefx.com/docs/houdini/nodes/sop/kinefx--smoothmotion.html" target="_blank">Smooth Motion</a> node, which it turns out runs on points too. Harrison Molling mentioned CHOPs, which have <a href="https://www.sidefx.com/docs/houdini/nodes/chop/filter.html" target="_blank">Filter</a> and <a href="https://www.sidefx.com/docs/houdini/nodes/chop/pass.html" target="_blank">Pass Filter</a> nodes.</p>
						<p>I only learnt this after making my own methods. Lots of this is new to Houdini, so stick around!</p>
						<ol>
							<li>
								<a href="#method-1-lerp">Lerp</a> (simplest lowpass, used for games)
							</li>
							<li>
								<a href="#method-2-convolution">Convolution</a> (gaussian blur, box blur, sharpening, used for images)
							</li>
							<li>
								<a href="#method-3-biquad-filters">Biquad filters</a> (low pass, high pass, butterworth, etc, used for audio EQs)
							</li>
							<li>
								<a href="#method-4-fir-filters">FIR filters</a> (convolution and biquads combined)
							</li>
						</ol>
					</section>
					<div id="content">
						<h2 id="method-1-lerp">Method 1: Lerp</h2>
						<p>The easiest way to smooth stuff is with lerp, <a href="./Lerp" target="_blank">which I wrote about here</a>. It's really popular for games, especially in Unity. It's not a good method, but it's a nice intro to the topic.</p>
						<p>The idea is you start at some value, then pick a target value. Each frame you move a little bit closer to the target by some percentage. The slower you move, the smoother your path becomes.</p>
						<pre><code class="language-js">current = lerp(current, target, factor);</code></pre>
						<p>Here's a demo with the smooth version in white. Click and drag to draw your own data.</p>
						<div>
							<canvas id="lerpCanvas" width="640" height="200" style="cursor: pointer;"></canvas>
						</div>
						<div>
							<canvas id="lerpLiveCanvas" width="640" height="32"></canvas>
						</div>
						<div class="mb-3">
							<label for="lerpFactor">Factor</label>
							<input id="lerpFactor" type="range" min="0" max="1" step="0.01" value="0.1">
							<span id="lerpFactorValue"></span>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("lerpCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("lerpFactor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("lerpFactorValue");
							lerpValue.textContent = lerpFac;

							const data = generateData(Math.floor(canv.width * 0.5));
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#DD2020";
								drawData(canv, ctx, data, 1);
								
								ctx.strokeStyle = "white";
								ctx.beginPath();
								let current = data[0];
								for (let i = 0; i < data.length; ++i) {
									// The magic formula
									current = lerp(current, data[i], lerpFac);
									ctx.lineTo(i / (data.length - 1) * canv.width, (0.5 - current) * canv.height);
								}
								ctx.stroke();
							}
							
							draw();

							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});

							canv.addEventListener("mousedown", function(e) {
								mouseClickData(e, canv, data, 1);
								draw();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, data, 1);
								draw();
							});

							const canv2 = document.getElementById("lerpLiveCanvas");
							const ctx2 = canv2.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv2);

							let target = Math.random() * (canv2.width - canv2.height);
							let current = 0;

							function drawLive() {
								drawBackground(canv2, ctx2);

								const blockSize = canv2.height * 0.5;

								// Draw target value
								ctx2.fillStyle = "#FF0000";
								ctx2.fillRect(target, blockSize * 0.5, blockSize, blockSize);

								// Draw current value
								ctx2.fillStyle = "white";
								ctx2.fillRect(current, blockSize * 0.5, blockSize, blockSize);

								// The magic formula
								current = lerp(current, target, lerpFac);

								requestFrame(drawLive);
							}

							requestFrame(drawLive);

							let hovering = false;

							canv2.addEventListener("mouseenter", function(e) {
								hovering = true;
							});

							canv2.addEventListener("mouseleave", function(e) {
								hovering = false;
							});

							// Move target to new position
							window.setInterval(function() {
								if (hovering) return;
								target = Math.random() * (canv2.width - canv2.height);
							}, 1000);

							canv2.addEventListener("mousemove", function(e) {
								target = e.offsetX;
							});
						})();
						</script>
						<p>There's 3 big problems with this method, which all smoothing methods suffer from.</p>
						<h3>Problem 1: Phase shift</h3>
						<p>If you set the slider really low, it looks like the graph moves to the right. This is called <b>phase shift</b>.</p>
						<p>It happens since the value is too lazy in moving to the target, so it sticks near the previous value and smears out the graph.</p>
						<p>Phase shift is a popular topic in music, you'll find many audio engineers rambling about it online (<a href="https://www.youtube.com/@DanWorrall" target="_blank">Dan Worrall</a> is my favourite). When you use an equalizer on music (for example to boost the bass), it usually adds a bit of phase shift. Some plugins (like <a href="https://ddmf.eu/plugindoctor/" target="_blank">Plugindoctor</a>) even show you the exact phase shift you'll get. This is called the <b>phase response</b>.</p>
						<p>Phase shift is a natural part of the universe so there's nothing wrong with it, but it's annoying if you want stuff to line up. The lazy way is shifting over the graph. The proper way is using <b>linear phase</b> filters. Linear phase filters always need values forwards in time as well as backwards.</p>
						<p>The simplest way is smoothing forwards, then smoothing backwards. This cancels out the phase shift and makes a linear phase filter. Here's a demo with the original version in red, and the linear phase version in green.</p>
						<div>
							<canvas id="lerp3Canvas" width="640" height="200" style="cursor: pointer;"></canvas>
						</div>
						<div class="mb-3">
							<label for="lerp3Factor">Factor</label>
							<input id="lerp3Factor" type="range" min="0" max="1" step="0.01" value="0.02">
							<span id="lerp3FactorValue"></span>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("lerp3Canvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("lerp3Factor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("lerp3FactorValue");
							lerpValue.textContent = lerpFac;

							const data = generateData(Math.floor(canv.width * 0.5));
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#808080";
								drawData(canv, ctx, data, 1);
								
								// Lerp forwards in time
								ctx.strokeStyle = "#FF0000";
								ctx.beginPath();
								const dataCopy = data.slice();
								let current = dataCopy[0];
								for (let i = 0; i < dataCopy.length; ++i) {
									// The magic formula
									current = lerp(current, dataCopy[i], lerpFac);
									ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
									dataCopy[i] = current;
								}
								ctx.stroke();

								// Lerp backwards in time
								ctx.strokeStyle = "#00FF00";
								ctx.beginPath();
								current = dataCopy[dataCopy.length - 1];
								for (let i = dataCopy.length - 1; i >= 0; --i) {
									// The magic formula
									current = lerp(current, dataCopy[i], lerpFac);
									ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
								}
								ctx.stroke();
							}
							
							draw();

							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});

							canv.addEventListener("mousedown", function(e) {
								mouseClickData(e, canv, data, 1);
								draw();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, data, 1);
								draw();
							});
						})();
						</script>

						<h3>Problem 2: Oversmoothing</h3>
						<p>You'll find this method is hard to control. It tends to smooth everything too much or not enough.</p>
						<p>This is because of the <b>order</b> of the filter. The order basically means how sharp and precise a filter is. Here's a nice diagram from <a href="https://www.electronics-tutorials.ws/filter/filter_8.html" target="_blank">Electronics Tutorials</a>. You can see as the order increases the curve gets steeper, meaning it cuts precisely and doesn't smudge everything.</p>
						<img src="./images/smoothing/filterorder.png" class="mb-3 mw-100">
						<p>The lerp method is a <a href="https://tomroelandts.com/articles/low-pass-single-pole-iir-filter" target="_blank">first order IIR lowpass</a>, so it's pretty blunt and tends to smudge everything out.</p>
						<p>Turns out there's a cool trick to improve it. If you stack a bunch of low order filters, you approximate a high order filter. This works surprisingly well, though it's much slower and smudgier than doing it properly.</p>
						<p>Here's a demo with the original filter in red, and the layered filters coloured towards purple. Try drawing some data and watch it move!</p>
						<div>
							<canvas id="lerp2Canvas" width="640" height="200" style="cursor: pointer;"></canvas>
						</div>
						<div class="d-flex flex-column flex-sm-row mb-3 gap-3">
							<div>
								<div>
									<label for="lerp2Factor">Factor:</label>
									<span id="lerp2FactorValue"></span>
								</div>
								<input id="lerp2Factor" type="range" min="0" max="1" step="0.01" value="0.1">
							</div>
							<div>
								<div>
									<label for="lerp2Layers">Layers:</label>
									<span id="lerp2LayersValue"></span>
								</div>
								<input id="lerp2Layers" type="range" min="1" max="50" step="1" value="10">
							</div>
							<div>
								<input id="lerp2Linear" type="checkbox">
								<label for="lerp2Linear">Linear Phase</label>
							</div>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("lerp2Canvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("lerp2Factor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("lerp2FactorValue");
							lerpValue.textContent = lerpFac;

							const layersSlider = document.getElementById("lerp2Layers");
							let lerpLayers = parseFloat(layersSlider.value);

							const layersValue = document.getElementById("lerp2LayersValue");
							layersValue.textContent = lerpLayers;

							const linearToggle = document.getElementById("lerp2Linear");
							let linearPhase = linearToggle.checked;

							const data = generateData(Math.floor(canv.width * 0.5));
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#808080";
								drawData(canv, ctx, data, 1);

								// Chain the crappy lowpass filter to approximate a higher order lowpass filter
								const dataCopy = data.slice();
								for (let j = 0; j < lerpLayers; ++j) {

									ctx.strokeStyle = `hsl(${j / lerpLayers * 360}, 100%, 70%)`;
									ctx.beginPath();

									// Lerp forwards in time
									let current = dataCopy[0];
									for (let i = 0; i < dataCopy.length; ++i) {
										// The magic formula
										current = lerp(current, dataCopy[i], lerpFac);
										if (!linearPhase) {
											ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
										}
										dataCopy[i] = current;
									}

									// Lerp backwards in time
									if (linearPhase) {
										current = dataCopy[dataCopy.length - 1];
										for (let i = dataCopy.length - 1; i >= 0; --i) {
											// The magic formula
											current = lerp(current, dataCopy[i], lerpFac);
											ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
											dataCopy[i] = current;
										}
									}
									ctx.stroke();
								}
							}
							
							draw();
							
							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});
							
							layersSlider.addEventListener("input", function(e) {
								lerpLayers = parseFloat(e.target.value);
								layersValue.textContent = lerpLayers;
								draw();
							});

							linearToggle.addEventListener("input", function(e) {
								linearPhase = e.target.checked;
								draw();
							});

							canv.addEventListener("mousedown", function(e) {
								mouseClickData(e, canv, data, 1);
								draw();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, data, 1);
								draw();
							});
						})();
						</script>
						<h3>Problem 3: Undershooting</h3>
						<p>When the slider is below 1, it never actually reaches the target.</p>
						<p>You can tell from the formula. Lerp takes a percentage of two values and adds them together <a href="./Lerp" target="_blank">as described here</a>. For example if the factor is 0.9, it takes 10% of the current value and adds on 90% of the target value. That means you never get 100% of the target.</p>
						<p>Here's a demo where the white line targets the red line. Though it may appear to, it always lies below the red line until the factor is 1.</p>
						<div>
							<canvas id="undershootCanvas" width="640" height="200"></canvas>
						</div>
						<div class="mb-3">
							<label for="undershootFactor">Factor</label>
							<input id="undershootFactor" type="range" min="0" max="1" step="0.01" value="0.1">
							<span id="undershootFactorValue"></span>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("undershootCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("undershootFactor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("undershootFactorValue");
							lerpValue.textContent = lerpFac;
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#FF0000";
								drawLine(canv, ctx, 0, canv.height * 0.2, canv.width, canv.height * 0.2);
								
								ctx.strokeStyle = "white";
								ctx.beginPath();
								let current = 0.8;
								for (let i = 0; i <= canv.width; i += 8) {
									// The magic formula
									current = lerp(current, 0.2, lerpFac);
									ctx.lineTo(i, current * canv.height);
								}
								ctx.stroke();
							}
							
							draw();
							
							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});
						})();
						</script>
						<h3>Running this in Houdini</h3>
						<p>To get this into Houdini, we need a way to access the previous frame. Luckily there's many ways to do this.</p>
						<h4>Option 1: Solver</h4>
						<p>Solvers are the most accurate and robust for this method. They run in sequence and never skip any frames, so if we had a huge jolt it continues smoothing out the impact forever. However they can't be run in parallel, so they're not ideal for farms.</p>
						<p>First add a Solver node, then a Point Wrangle inside. Plug the the current animation (Input_1) into the second wrangle input.</p>
						<img src="./images/smoothing/lerpwrangle.PNG" width="640" class="mb-3 mw-100">
						<p>Now we can write the formula in VEX. In solvers, <code>@P</code> is the current position. The second input we connected <code>@opinput1_P</code> is the latest animation, which is our target position.</p>
						<pre><code class="language-js">v@P = lerp(v@P, v@opinput1_P, chf("factor"));</code></pre>
						<p>Here's before and after. It smooths out most of the noise, but reduces the range of motion too much.</p>
						<img src="./images/smoothing/lerpsmoothsolver.webp" width="640" class="mw-100">
						<div class="my-2">
							<a href="./hips/smoothing/lerp_smooth_solver.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<p>Although solvers are ideal, we can get a decent approximation with Trail.</p>
						<h4 id="option-2-trail">Option 2: Trail</h4>
						<p>Instead of sampling all past frames, it's faster to sample a handful of past frames and try to guess the future from them. This is called a <b>sliding window</b> technique, which Catherine used for her demo. It's good for production since it can be batch processed and run in parallel. <a href="https://www.shadertoy.com/view/dtlSWH" target="_blank">I used it to make a GPU equalizer</a>. However it's bad news for lerp, since lerp <a href="#method-4-fir-filters">can't react to jolts</a> if it doesn't know they happened.</p>
						<p>To try it anyway, add a Trail node and a Point Wrangle. Plug Trail into the second wrangle input.</p>
						<img src="./images/smoothing/trailwrangle.PNG" width="640" class="mb-3 mw-100">
						<p>For dense meshes, it helps to cache Trail for better performance.</p>
						<p>Now we need to extract positions from different frames. This is done using <code>point()</code>. It has 3 arguments, but we only care about the last one.</p>
						<pre><code class="language-js">vector pos = point(0, "P", point_number);</code></pre>
						<p>Given the current point number <code>@ptnum</code>, we need to find the matching point number on the previous frame. Assuming the topology stays the same, you'll find a pattern. Let's say your <code>@ptnum</code> is 0. If the mesh has 5 points, your <code>@ptnum</code> on the previous frame will be 5, 10, 15, 20 and so on. This happens since the Trail node merges batches of 5 points per frame.</p>
						<p>Using <code>npoints(0)</code> to get the number of points in the mesh, the general formula is <code>@ptnum + npoints(0) * frame</code></p>
						<img src="./images/smoothing/trailframes.png" class="mb-3 w-100">
						<p>Using this idea we can lerp through the positions from past to present, just like with the solver. No dictionaries or maps required!</p>
						<pre><code class="language-js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);

// Start at the last frame's position (the oldest frame)
v@P = point(1, "P", i@ptnum + point_count * (trail_length - 1));

// Lerp from the past to the present, like the solver except manually
for (int frame = 1; frame &lt; trail_length; ++frame) {
	// Get the corresponding point position on the next frame
	vector target_pos = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
	// The magic formula
	v@P = lerp(v@P, target_pos, chf("factor"));
}</code></pre>
						<p>Here's before and after. It looks pretty similar, but jitters more since it keeps forgetting past samples.</p>
						<img src="./images/smoothing/lerpsmoothtrail.webp" width="640" class="mw-100">
						<div class="my-2">
							<a href="./hips/smoothing/lerp_smooth_trail.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<p>Sadly this version suffers from phase shift, just like the solver. The great thing with Trail is it doesn't have to. We can make linear phase filters and stack them too!</p>
						<h5 id="lerp-linear">Linear phase version</h5>
						<p>First we need a way to get frames forwards in time as well as backwards. This is as easy as adding a Time Shift node after Trail.</p>
						<img src="./images/smoothing/trailtimeshift.png" width="640" class="mb-3 mw-100">
						<p>Set the frame offset to <code>$F + (ch("../trail1/length") - 1) / 2</code>. This centers the current frame, so we have the same number of frames forwards and backwards in time.</p>
						<img src="./images/smoothing/trailframeoffset.png" width="860" class="mb-3 mw-100">
						<p>Next we can reuse the same frame offset idea from before, except this time filtering in both directions.</p>
						<pre><code class="language-js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);
float factor = chf("factor");
int layers = chi("layers");

// Build an array of all positions on all frames
// For optimization, you could do a forward lerp in here
vector pos[];
resize(pos, trail_length);
for (int frame = 0; frame < trail_length; ++frame) {
	pos[frame] = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
}

// Smooth a bunch of times in a row (if you want)
for (int i = 0; i < layers; ++i) {

	// Smooth forwards in time
	vector current_pos = pos[0];
	for (int frame = 1; frame < trail_length; ++frame) {
		// The magic formula
		pos[frame] = lerp(current_pos, pos[frame], factor);
		current_pos = pos[frame];
	}

	// Smooth backwards in time
	current_pos = pos[trail_length - 1];
	for (int frame = trail_length - 2; frame >= 0; --frame) {
		// The magic formula
		pos[frame] = lerp(current_pos, pos[frame], factor);
		current_pos = pos[frame];
	}
}

// Get the center frame, which is our frame
v@P = pos[trail_length / 2];</code></pre>
						<p>Thanks to looking into the future, we can anticipate motion before it even happens. Here's a demo with the linear phase version in green and the original version in red.</p>
						<img src="./images/smoothing/lerpsmoothtraillinear.webp" width="540" class="mw-100">
						<div class="my-2">
							<a href="./hips/smoothing/lerp_smooth_trail_linear.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<p>While lerp works OK, there's plenty of fancier methods of smoothing out stuff. Let's learn about convolution!</p>
						<h2 id="method-2-convolution">Method 2: Convolution</h2>
						<p>Convolution solves many problems we were having before. It's linear phase and only needs a handful of frames, making it perfect for batch processing. It's a weighted sum just like lerp, but it's much more powerful than you'd expect. It works for smoothing, sharpening, embossing and all kinds of cool filters.</p>
						<p>It works by picking a value, sampling the neighbours around it, multiplying them and adding them together. It's like what we did with lerp, except now we have precise control over how much each neighbour contributes to the final result. We can totally ignore neighbours or even flip their influence.</p>
						<p>For example, say you want each value to be the average of its 2 neighbours. For that you can use the kernel <code>[0.5, 0, 0.5]</code>.</p>
						<img src="./images/smoothing/convolution.png" width="640" class="mb-3 mw-100">
						<p>Here we sample 9's neighbours (4 and 6), then calculate <code>4 * 0.5 + 9 * 0 + 6 * 0.5 = 5</code>. In other words, ignore 9 and average 4 and 6 together.</p>
						<p>The key idea of convolution is you can slide the kernel up and down. Click and drag to see what I mean!</p>
						<div>
							<canvas id="convCanvas" width="720" height="360" style="cursor: pointer;"></canvas>
						</div>
						<table class="mb-3 user-select-none">
							<tr class="text-center">
								<td class="pe-3">
									<span id="convXWeightValue"></span>
								</td>
								<td class="pe-3">
									<span id="convYWeightValue"></span>
								</td>
								<td class="pe-3">
									<span id="convZWeightValue"></span>
								</td>
								<td>
									<input id="convAll" type="checkbox">
									<label for="convAll">Convolve All</label>
								</td>
							</tr>
							<tr>
								<td class="pe-3">
									<input id="convXWeight" type="range" min="0" max="1" step="0.1" value="0.5">
								</td>
								<td class="pe-3">
									<input id="convYWeight" type="range" min="0" max="1" step="0.1" value="0">
								</td>
								<td class="pe-3">
									<input id="convZWeight" type="range" min="0" max="1" step="0.1" value="0.5">
								</td>
							</tr>
						</table>
						<script>
						(function(){
							const canv = document.getElementById("convCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const xSlider = document.getElementById("convXWeight");
							let xWeight = parseFloat(xSlider.value);

							const xValue = document.getElementById("convXWeightValue");
							xValue.textContent = xWeight;

							const ySlider = document.getElementById("convYWeight");
							let yWeight = parseFloat(ySlider.value);

							const yValue = document.getElementById("convYWeightValue");
							yValue.textContent = yWeight;

							const zSlider = document.getElementById("convZWeight");
							let zWeight = parseFloat(zSlider.value);

							const zValue = document.getElementById("convZWeightValue");
							zValue.textContent = zWeight;

							const convToggle = document.getElementById("convAll");
							let convAll = convToggle.checked;

							const data = generateRandomData(Math.floor(canv.width / 16));
							let kernelPos = Math.floor(data.length * 0.5);

							let weights;
							function updateWeights() {
								weights = [xWeight, yWeight, zWeight];
							}
							updateWeights();

							function draw() {
								drawBackground(canv, ctx);
								drawConvolution(canv, ctx, data, kernelPos, weights, convAll);
							}

							draw();

							xSlider.addEventListener("input", function(e) {
								xWeight = parseFloat(e.target.value);
								xValue.textContent = xWeight;
								updateWeights();
								draw();
							});

							ySlider.addEventListener("input", function(e) {
								yWeight = parseFloat(e.target.value);
								yValue.textContent = yWeight;
								updateWeights();
								draw();
							});

							zSlider.addEventListener("input", function(e) {
								zWeight = parseFloat(e.target.value);
								zValue.textContent = zWeight;
								updateWeights();
								draw();
							});

							convToggle.addEventListener("input", function(e) {
								convAll = e.target.checked;
								draw();
							});

							function moveKernel(e) {
								kernelPos = Math.round(e.offsetX / canv.width * (data.length - 1) - weights.length * 0.5);
								draw();
							}

							canv.addEventListener("mousedown", moveKernel);
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								moveKernel(e);
							});
						})();
						</script>
						<p>Tick "Convolve All" to see the full convolution, then mess with the weights to see what you find! Here's a few you can try:</p>
						<ul>
							<li>The kernel <code>[1, 0, 0]</code> shifts everything 1 unit to the right.</li>
							<li>The kernel <code>[0, 0, 1]</code> shifts everything 1 unit to the left.</li>
							<li>The kernel <code>[0, 1, 0]</code> keeps everything the same.</li>
							<li>The kernel <code>[1, 1, 1]</code> sums all 3 values together.</li>
							<li>The kernel <code>[1, 1, 0]</code> sums the previous and current value.</li>
							<li>The kernel <code>[0, 1, 1]</code> sums the current and next value.</li>
							<li>The kernel <code>[1, 0, 1]</code> sums both neighbours.</li>
							<li>The kernel <code>[0.5, 0, 0.5]</code> averages the two neighbours together.</li>
							<li>The kernel <code>[0.5, 0.5, 0]</code> averages the previous and current value.</li>
							<li>The kernel <code>[0, 0.5, 0.5]</code> averages the current and next value.</li>
						</ul>
						<p>With a tiny size 3 kernel, we can already do so many things. Hopefully this gives you an idea of how powerful and versatile convolution is.</p>
						<h3>Gaussian blur</h3>
						<p>Gaussian blur is one of the many things we can do with convolution. We just need to replace our kernel with a gaussian kernel. It looks like this.</p>
						<img src="./images/smoothing/gaussiankernel.png" width="512" class="mb-3 mw-100">
						<p>Stripping the formula to the bones, you can write it as <code>exp(-x * x / (size * size))</code>, where <code>x</code> is the value and <code>size</code> is the width of the shape. It extends infinitely, so you need to pick a size that fits most of it between -1 and 1. I found dividing <code>size</code> by 3 works pretty well, or in other words <code>exp(-9 * x * x / (size * size))</code>. Then we normalize it so all values add to 1.</p>
						<p>And just like that we have gaussian blur! Change the kernel size to set the intensity.</p>
						<div>
							<canvas id="gaussianCanvas" width="720" height="360" style="cursor: pointer;"></canvas>
						</div>
						<table class="mb-3">
							<tr>
								<td class="pe-3">
									<label for="gaussSize">Kernel Size:</label>
									<span id="gaussSizeValue"></span>
								</td>
								<td>
									<input id="gaussConvAll" type="checkbox" checked>
									<label for="gaussConvAll">Convolve All</label>
								</td>
							</tr>
							<tr>
								<td class="pe-3">
									<input id="gaussSize" type="range" min="1" max="65" step="2" value="5">
								</td>
							</tr>
						</table>
						<script>
						(function(){
							const canv = document.getElementById("gaussianCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const convToggle = document.getElementById("gaussConvAll");
							let convAll = convToggle.checked;

							const sizeSlider = document.getElementById("gaussSize");
							let gaussSize = parseInt(sizeSlider.value);

							const sizeValue = document.getElementById("gaussSizeValue");
							sizeValue.textContent = gaussSize;

							const data = generateRandomData(Math.floor(canv.width / 16));
							let kernelPos = Math.floor(data.length * 0.5);
							let weights = gaussianKernel(5);

							function draw() {
								drawBackground(canv, ctx);
								drawConvolution(canv, ctx, data, kernelPos, weights, convAll);
							}

							draw();

							convToggle.addEventListener("input", function(e) {
								convAll = e.target.checked;
								draw();
							});

							sizeSlider.addEventListener("input", function(e) {
								gaussSize = parseInt(e.target.value);
								sizeValue.textContent = gaussSize;
								weights = gaussianKernel(gaussSize);
								draw();
							});

							function moveKernel(e) {
								kernelPos = Math.round(e.offsetX / canv.width * (data.length - 1) - weights.length * 0.5);
								draw();
							}

							canv.addEventListener("mousedown", moveKernel);
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								moveKernel(e);
							});
						})();
						</script>
						<h3>Running this in Houdini</h3>
						<p>To get this into Houdini, we can reuse the trail setup from the lerp section with a few minor changes.</p>
						<p>First we need to make the kernel. We can do it in a Detail Wrangle since it never changes and only needs to be built once.</p>
						<img src="./images/smoothing/detailwrangle.png" width="640" class="mb-3 mw-100">
						<p>Let's store the kernel in a detail attribute. The syntax is pretty ugly, <code>f[]@kernel</code> just means an array of floats.</p>
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");

// Width of shape, divided by 3 so it fits snugly between -1 and 1
float size = trail_length / 3.0;

// Preallocate array size
resize(f[]@kernel, trail_length);
f@kernel_sum = 0;

// Build gaussian kernel (array of floats)
for (int i = 0; i < trail_length; ++i) {
	// Center it on the middle value
	float x = i - (trail_length - 1) / 2.0;
	f[]@kernel[i] = exp(-x * x / (size * size));
	f@kernel_sum += f[]@kernel[i];
}</code></pre>
						<p>Now we dump in the Trail, Time Shift and Point Wrangle from the lerp section. Like before, the frame offset is <code>$F + (ch("../trail1/length") - 1) / 2</code>.</p>
						<img src="./images/smoothing/detailwrangle2.png" width="640" class="mb-3 mw-100">
						<p>Now onto the convolution. It's surprisingly easy since Trail and Time Shift did the hard work for us. We just need to add up all the values multiplied by their respective weights.</p>
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);

// Convolve all frames to get the current frame
vector pos_total = 0;
for (int frame = 0; frame < trail_length; ++frame) {
	vector pos = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
	pos_total += pos * f[]@kernel[frame];
}

// Normalize so it adds to 1
v@P = pos_total / f@kernel_sum;</code></pre>
						<p>The trail length directly controls the amount of blur. The more frames we sample, the more we can blur.</p>
						<table class="text-center">
							<tr>
								<th>23 frames</th>
								<th>61 frames</th>
							</tr>
							<tr>
								<td>
									<img src="./images/smoothing/convolutiontrail.webp" width="640" class="mw-100">
								</td>
								<td>
									<img src="./images/smoothing/convolutiontrail2.webp" width="640" class="mw-100">
								</td>
							</tr>
						</table>
						<div class="my-2">
							<a href="./hips/smoothing/convolution_smoothing.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<p>Now I know what you're thinking. This looks exactly like the lerp method from before! What's the point of going through all that effort?</p>
						<p>Well firstly, it properly reaches the target unlike the lerp method. And secondly, you can swap out the kernel to get cool effects!</p>
						<h4>Cool kernels</h4>
						<p>Here's a cool kernel I made by accident. It turns any animation into an incredible springy mess!</p>
						<img src="./images/smoothing/springykernel.png" width="960" class="mb-3 mw-100">
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");

// Preallocate array size
resize(f[]@kernel, trail_length);
f@kernel_sum = 0;

// Build insane kernel
float insanity = 2;
for (int i = 0; i < trail_length; ++i) {
	// Center it on the middle value
	float x = i - (trail_length - 1) / 2.0;
	// Normalize the range
	x /= trail_length;
	// Invoke madness
	f[]@kernel[i] = cos(2 * PI * x) * (insanity - abs(x));
	f@kernel_sum += f[]@kernel[i];
}</code></pre>
						<img src="./images/smoothing/convolutionspringy.webp" width="640" class="mw-100">
						<div class="my-2">
							<a href="./hips/smoothing/convolution_springy.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<p>This way of building kernels is ugly and hard. It'd be nicer if we could draw kernels visually with a ramp.</p>
						<p>We can delete the Detail Wrangle and just use the Point Wrangle, since the ramp stores the kernel for us.</p>
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);

// Convolve all frames to get the current frame
vector pos_total = 0;
float kernel_sum = 0;

for (int frame = 0; frame < trail_length; ++frame) {
	vector pos = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
	float weight = chramp("kernel", float(frame) / (trail_length - 1));
	pos_total += pos * weight;
	kernel_sum += weight;
}

// Normalize so it adds to 1
if (chi("normalize_kernel")) {
	pos_total /= kernel_sum;
}

v@P = pos_total;</code></pre>
						<p>Now we can easily experiment with different shapes! I found this one also has a crazy effect on the motion.</p>
						<img src="./images/smoothing/rampkernel.png" width="860" class="mb-3 mw-100">
						<p>TODO: ADD DEMO AND HIP FILE</p>
						<h4>Sharpening kernels</h4>
						<p>Sharpening kernels are usually positive in the middle and negative on the sides. Here's one I drew to exaggerate the motion.</p>
						<img src="./images/smoothing/sharpenramp.png" width="860" class="mb-3 mw-100">
						<table class="text-center">
							<tr>
								<th>15 frames</th>
								<th>35 frames</th>
							</tr>
							<tr>
								<td>
									<img src="./images/smoothing/convolutioncustom.webp" width="640" class="mw-100">
								</td>
								<td>
									<img src="./images/smoothing/convolutioncustom2.webp" width="640" class="mw-100">
								</td>
							</tr>
						</table>
						<div class="my-2">
							<a href="./hips/smoothing/convolution_custom.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<h4>Blurring kernels</h4>
						<p>We can make blurry kernels too, just like before. To make box blur (also called a moving average), just draw a flat line.</p>
						<img src="./images/smoothing/boxblur.png" width="860" class="mb-3 mw-100">
						<p>To approximate gaussian blur, draw a bell curve centered at 0.5.</p>
						<img src="./images/smoothing/gaussianblur.png" width="860" class="mb-3 mw-100">
						<p>Here's a demo with gaussian blur in blue and box blur in green. Box blur tends to blur more aggressively since it uses all samples equally.</p>
						<img src="./images/smoothing/convolutionblurs.webp" width="640" class="mw-100">
						<div class="my-2">
							<a href="./hips/smoothing/convolution_blurs.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<h3>Topology convolution</h3>
						<p>Going off track for a bit, I started wondering what happens if you convolve geometry instead of time.</p>
						<p>Convolution just needs neighbours and weights. Let's sample a bunch of nearby points, multiply them by weights and add them together. Just like Attribute Blur, we could do it by connectivity or proximity.</p>
						<div class="my-2">
							<a href="./hips/smoothing/convolution_topology.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<h4>Option 1: Connectivity</h4>
						<p>If the geometry is connected by edges, we can weigh each point by how many edges away it is from the current point.</p>
						<p>For example, TODO: ADD LINE DIAGRAM HERE</p>
						<p>This gets biased by the point count and I didn't even scale it by edge lengths, but it's worth a try anyway.</p>
						<h4>Option 2: Proximity</h4>
						<p>If we have a disconnected point cloud, we can weigh each point by its distance from the current point.</p>
						<p>For example, TODO: ADD DIAGRAM HERE</p>
						<p>I thought it'd would work better since edge lengths won't affect it, but it still gets biased by clusters of points with similar distances.</p>
						<p>Anyway, back on track. Let's jump to the most advanced filters I know!</p>
						<h2 id="method-3-biquad-filters">Method 3: Biquad filters</h2>
						<p>Biquad filters are extremely popular for music and sound design. They're used for most digital equalizers, so when you boost the bass or cut the treble, you're likely using a biquad filter.</p>
						<p>They give you full control over the frequency response, so you can make precise changes without affecting other frequencies. Best of all, they're fast and easy to run. It barely takes any code to run a biquad filter, seen later in this article.</p>
						<p>Have a play with this demo. Try to get a feel for how time and frequency interact.</p>
						<p class="mb-2">
							<b>Time Domain</b>
						</p>
						<div>
							<canvas id="biquadCanvas" width="720" height="256" style="cursor: pointer;"></canvas>
						</div>
						<p class="mb-2">
							<b>Frequency Domain</b>
						</p>
						<div class="mb-1">
							<canvas id="biquadCanvas2" width="720" height="256"></canvas>
						</div>
						<div class="mb-2">
							<button id="addFilter" class="btn btn-primary me-3"><i class="bi bi-plus-lg"></i> Add filter</button>
							<div class="float-end">
								<input id="biquadLinear" type="checkbox">
								<label for="biquadLinear">Linear Phase</label>
								<input id="biquadDecibels" type="checkbox" checked>
								<label for="biquadDecibels">Decibel Scale</label>
							</div>
						</div>
						<div id="filterList" class="mb-3"></div>
						<script>
						(function(){
							// Scale down amplitude so -36dB fits on canvas
							const dbScale = 36;
							// Scale down waveform so full amplitude fits on canvas
							const ampScale = 0.3;
							
							const addFilterElem = document.getElementById("addFilter");
							const filterListElem = document.getElementById("filterList");
							let filters = [];
							
							const canv = document.getElementById("biquadCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);
							
							const useDecibelsToggle = document.getElementById("biquadDecibels");
							let useDecibels = useDecibelsToggle.checked;

							const linearPhaseToggle = document.getElementById("biquadLinear");
							let linearPhase = linearPhaseToggle.checked;
							
							const numSamples = Math.floor(canv.width * 0.5);
							const sampleRate = numSamples;
							
							// We can't measure anything above half the sample rate
							const nyquist = Math.floor(sampleRate * 0.5);
							
							// Storage for time domain waveform
							const timeBefore = new Float32Array(numSamples); // Before filtering
							const timeAfter = new Float32Array(numSamples); // After filtering
							
							// Storage for frequency response of all filters
							const freqResponse = new Float32Array(numSamples);
							
							// Storage for frequency domain magnitudes
							const freqBefore = new Float32Array(nyquist); // Before filtering
							const freqAfter = new Float32Array(nyquist); // After filtering

							// Waves complete a cycle after PI * sampleRate (nyquist * 2)
							for (let i = 0; i < numSamples; ++i) {
								const factor = i / numSamples;
								const lowFreq = Math.sin(factor * Math.PI * nyquist * 0.1);
								const noiseAmount = Math.cos(factor * 15) + 1;
								const rand = Math.random() - 0.5;
								timeBefore[i] = lowFreq * 0.5 + rand * noiseAmount;
							}		
							
							function getCoefficients(type, freq, Q, dbGain) {
								const A = Math.pow(10, dbGain / 40);
								const omega = 2 * Math.PI * freq / sampleRate;
								const sn = Math.sin(omega);
								const cs = Math.cos(omega);

								// Using Q alpha to make it easier to visualize
								const alpha = sn / (2 * Q);
								const beta = Math.sqrt(A + A);
								
								// From "Simple implementation of Biquad filters" by Tom St Denis
								let a0, a1, a2, b0, b1, b2;
								switch (type) {
								case 0:
									// Low pass
									b0 = (1 - cs) * 0.5;
									b1 = 1 - cs;
									b2 = (1 - cs) * 0.5;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 1:
									// High pass
									b0 = (1 + cs) * 0.5;
									b1 = -(1 + cs);
									b2 = (1 + cs) * 0.5;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 2:
									// Band pass
									b0 = alpha;
									b1 = 0;
									b2 = -alpha;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 3:
									// Notch
									b0 = 1;
									b1 = -2 * cs;
									b2 = 1;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 4:
									// Peaking
									b0 = 1 + (alpha * A);
									b1 = -2 * cs;
									b2 = 1 - (alpha * A);
									a0 = 1 + (alpha / A);
									a1 = -2 * cs;
									a2 = 1 - (alpha / A);
									break;
								case 5:
									// Low shelf
									b0 = A * ((A + 1) - (A - 1) * cs + beta * sn);
									b1 = 2 * A * ((A - 1) - (A + 1) * cs);
									b2 = A * ((A + 1) - (A - 1) * cs - beta * sn);
									a0 = (A + 1) + (A - 1) * cs + beta * sn;
									a1 = -2 * ((A - 1) + (A + 1) * cs);
									a2 = (A + 1) + (A - 1) * cs - beta * sn;
									break;
								case 6:
									// High shelf
									b0 = A * ((A + 1) + (A - 1) * cs + beta * sn);
									b1 = -2 * A * ((A - 1) + (A + 1) * cs);
									b2 = A * ((A + 1) + (A - 1) * cs - beta * sn);
									a0 = (A + 1) - (A - 1) * cs + beta * sn;
									a1 = 2 * ((A - 1) - (A + 1) * cs);
									a2 = (A + 1) - (A - 1) * cs - beta * sn;
									break;
								}
								
								// These actually get used for filtering
								const c0 = b0 / a0;
								const c1 = b1 / a0;
								const c2 = b2 / a0;
								const c3 = a1 / a0;
								const c4 = a2 / a0;
								
								return new Float32Array([
									// Coefficients used to display the frequency response
									a0, a1, a2, b0, b1, b2,
									// Coefficients used for actual filtering
									c0, c1, c2, c3, c4
								]);
							}

							// Discrete fourier transform from https://www.youtube.com/watch?v=ITnPS8HGqLo
							function updateDFT(data) {
								for (let k = 0; k < data.length; ++k) {
									let real = 0;
									let imag = 0;
									for (let n = 0; n < timeBefore.length; ++n) {
										const phase = (2 * Math.PI * k * n) / timeBefore.length;
										real += Math.cos(phase) * timeBefore[n];
										imag -= Math.sin(phase) * timeBefore[n];
									}
									data[k] = Math.sqrt(real * real + imag * imag) / data.length;
								}
							}

							function updateTimeResponse() {
								timeAfter.set(timeBefore);

								// Use the original signal when no filters are active
								if (filters.length <= 0) return;
								
								for (let i = 0; i < filters.length; ++i) {
									const co = filters[i].coefficients;
									for (let j = 0; j < co.length; j += 11) {
										const c0 = co[j + 6];
										const c1 = co[j + 7];
										const c2 = co[j + 8];
										const c3 = co[j + 9];
										const c4 = co[j + 10];

										// Forwards in time
										let x1 = x2 = y1 = y2 = 0;
										for (let k = 0; k < timeAfter.length; ++k) {
											// Apply the filter
											const sample = timeAfter[k];
											const result = c0 * sample + c1 * x1 + c2 * x2 - c3 * y1 - c4 * y2;
											
											// Shift x1 to x2, sample to x1
											x2 = x1;
											x1 = sample;
											
											// Shift y1 to y2, result to y1
											y2 = y1;
											y1 = result;

											timeAfter[k] = result;
										}

										if (linearPhase) {
											// Backwards in time
											x1 = x2 = y1 = y2 = 0;
											for (let k = timeAfter.length - 1; k >= 0; --k) {
												// Apply the filter
												const sample = timeAfter[k];
												const result = c0 * sample + c1 * x1 + c2 * x2 - c3 * y1 - c4 * y2;
												
												// Shift x1 to x2, sample to x1
												x2 = x1;
												x1 = sample;
												
												// Shift y1 to y2, result to y1
												y2 = y1;
												y1 = result;

												timeAfter[k] = result;
											}
										}
									}
								}
							}
							
							// From https://www.desmos.com/calculator/m1m7rhdpda
							function getFreqResponse(co, i, pos) {
								const a0 = co[i];
								const a1 = co[i + 1];
								const a2 = co[i + 2];
								const b0 = co[i + 3];
								const b1 = co[i + 4];
								const b2 = co[i + 5];

								const fa = (b0 + b1 + b2) * 0.5;
								const fb = (a0 + a1 + a2) * 0.5;
								const fc = fa * fa - pos * (4 * b0 * b2 * (1 - pos) + b1 * (b0 + b2));
								const fd = fb * fb - pos * (4 * a0 * a2 * (1 - pos) + a1 * (a0 + a2));

								return Math.sqrt(fc / fd);
							}
							
							function updateFreqResponse() {
								for (let i = 0; i < freqResponse.length; ++i) {
									let pos = Math.sin(Math.PI * i / freqResponse.length * 0.5);
									pos *= pos;
									
									// Apply each filter in series, multiply all magnitudes together
									freqResponse[i] = 1;
									for (let j = 0; j < filters.length; ++j) {
										const co = filters[j].coefficients;
										for (let k = 0; k < co.length; k += 11) {
											let response = getFreqResponse(co, k, pos);
											// Since I used brute force linear phase by running the filter twice, the response is squared
											if (linearPhase) response *= response;
											freqResponse[i] *= response;
										}
									}
								}

								// Update frequency spectrum
								for (let i = 0; i < freqAfter.length; ++i) {
									const nearest = Math.floor(i / freqAfter.length * freqResponse.length);
									freqAfter[i] = freqBefore[i] * freqResponse[nearest];
								}
							}
							
							function drawTime() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#707070";
								
								// Draw middle line
								let yPos = 0.5 * canv.height;
								drawLine(canv, ctx, 0, yPos, canv.width, yPos);
								
								ctx.strokeStyle = "#FF0000";
								// Draw clipping top line
								yPos = (0.5 - ampScale) * canv.height;
								drawLine(canv, ctx, 0, yPos, canv.width, yPos);
								
								// Draw clipping bottom line
								yPos = (0.5 + ampScale) * canv.height;
								drawLine(canv, ctx, 0, yPos, canv.width, yPos);
								
								ctx.strokeStyle = "#808080";
								drawData(canv, ctx, timeBefore, ampScale);
								
								ctx.strokeStyle = "white";
								drawData(canv, ctx, timeAfter, ampScale);
							}
							
							const canv2 = document.getElementById("biquadCanvas2");
							const ctx2 = canv2.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv2);
							
							function drawMagnitudes(data) {
								ctx2.beginPath();
								ctx2.moveTo(0, canv2.height);
								for (let i = 0; i < data.length; ++i) {
									if (useDecibels) {
										yPos = canv2.height * 0.5 - (gainTodB(data[i]) / dbScale * 0.5) * canv2.height;
									} else {
										yPos = canv2.height - data[i] * canv2.height * 0.9;
									}
									ctx2.lineTo(i / (data.length - 1) * canv2.width, yPos);
								}
								ctx2.lineTo(canv2.width, canv2.height);
								ctx2.fill();
							}

							const controlSize = 12;
							let hoveredFilter, activeFilter;

							// My opinion on where the control knobs should be
							function getControlPos(filter) {
								let db = 0;
								let yPos;

								if (filter.type <= 3) {
									// For low, high, band and notch, use the Q value
									db = 6 * Math.log2(filter.Q);
									if (linearPhase) db *= 2;
									if (filter.type === 2) db = -db;
								} else if (filter.type <= 6) {
									// For shelf and peak, use the gain value
									db = filter.dbGain;
								}

								if (useDecibels) {
									yPos = canv2.height * 0.5 - (db / dbScale * 0.5) * canv2.height;
								} else {
									yPos = canv2.height - dbToGain(db) * canv2.height * 0.5;
								}

								return [filter.freq / nyquist * canv2.width, yPos];
							}
							
							function moveFilter(e) {
								if (!activeFilter) return;
								const xFactor = e.offsetX / canv2.width;
								const yFactor = e.offsetY / canv2.height;

								const freq = xFactor * nyquist;
								activeFilter.freq = freq;
								activeFilter.elems.freq.slider.value = freq;
								// Force rounding to slider step value
								activeFilter.elems.freq.value.textContent = activeFilter.elems.freq.slider.value;

								let dbGain;
								if (useDecibels) {
									dbGain = dbScale - 2 * dbScale * yFactor;
								} else {
									dbGain = gainTodB(2 - yFactor * 2);
								}

								if (activeFilter.type <= 3) {
									// For low, high, band and notch, adjust the Q value
									if (linearPhase) dbGain *= 0.5;
									if (activeFilter.type === 2) dbGain = -dbGain;
									const Q = Math.pow(2, dbGain / 6);
									activeFilter.Q = Q;
									activeFilter.elems.Q.slider.value = Q;
									// Force rounding to slider step value
									activeFilter.elems.Q.value.textContent = activeFilter.elems.Q.slider.value;
								} else if (activeFilter.type <= 6) {
									// For shelf and peak, adjust the gain
									activeFilter.dbGain = dbGain;
									activeFilter.elems.dbGain.slider.value = dbGain;
									// Force rounding to slider step value
									activeFilter.elems.dbGain.value.textContent = activeFilter.elems.dbGain.slider.value;
								}

								updateCoefficients(activeFilter);
								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							}

							function distance(x1, y1, x2, y2) {
								const xDist = x1 - x2;
								const yDist = y1 - y2;
								return Math.sqrt(xDist * xDist + yDist * yDist);
							}

							function getHoveredFilter(e) {
								for (let i = 0; i < filters.length; ++i) {
									const filter = filters[i];
									const pos = getControlPos(filter);
									const dist = distance(e.offsetX, e.offsetY, pos[0], pos[1]);
									if (dist < controlSize * 2) {
										return filter;
									}
								};
							}

							function drawFreq() {
								drawBackground(canv2, ctx2);
								
								// Draw volume divisions
								let yPos;
								ctx2.lineWidth = 1.5;
								ctx2.strokeStyle = "#707070";
								for (let i = 0; i <= 1; i += 0.1) {
									if (useDecibels) {
										yPos = canv2.height * 0.5 - (gainTodB(i) / dbScale * 0.5) * canv2.height;
									} else {
										yPos = canv2.height - i * canv2.height * 0.5;
									}
									drawLine(canv2, ctx2, 0, yPos, canv2.width, yPos);
								}
								
								// Draw clipping line
								ctx2.strokeStyle = "#FF0000";
								yPos = canv2.height * 0.5;
								drawLine(canv2, ctx2, 0, yPos, canv2.width, yPos);
								
								// Draw magnitudes before filtering
								ctx2.fillStyle = "#808080";
								drawMagnitudes(freqBefore);
								
								// Draw magnitudes after filtering
								ctx2.fillStyle = "#EEEEEE";
								drawMagnitudes(freqAfter);
								
								// Draw filter frequency response
								ctx2.strokeStyle = "white";
								ctx2.beginPath();
								for (let i = 0; i < freqResponse.length; ++i) {
									if (useDecibels) {
										yPos = canv2.height * 0.5 - (gainTodB(freqResponse[i]) / dbScale * 0.5) * canv2.height;
									} else {
										yPos = canv2.height - freqResponse[i] * canv2.height * 0.5;
									}
									ctx2.lineTo(i / (freqResponse.length - 1) * canv2.width, yPos);
								}
								ctx2.stroke();

								// Draw interactive filter controls
								filters.forEach(function(filter) {
									ctx2.fillStyle = hoveredFilter === filter ? "white" : filter.color;
									const size = hoveredFilter === filter ? controlSize * 1.5 : controlSize;
									const pos = getControlPos(filter);
									ctx2.fillRect(pos[0] - size * 0.5, pos[1] - size * 0.5, size, size);
								});
							}
							
							// Disable parameters which aren't used by certain filter types
							function disableElems(filter) {
								filter.elems.Q.div.style.display = filter.type > 4 ? "none" : "block";
								filter.elems.dbGain.div.style.display = (filter.type >= 4 && filter.type <= 6) ? "block" : "none";
								filter.elems.order.div.style.display = filter.type > 6 ? "block" : "none";
							}
							
							function updateCoefficients(filter) {
								let dbGain = filter.dbGain;

								// Try to match frequency response with linear phase enabled
								// Ideally the magnitude would be exactly sqrt but I don't know how to achieve that
								if (linearPhase) dbGain *= 0.5;

								if (filter.type >= 7) {
									// Butterworth filter, made by stacking biquads. Merge all biquad coefficients into one giant list
									// [a0, a1, a2, b0, b1, b2, c0, c1, c2, c3, c4, a0, a1, a2, b0, b1, b2...]
									const numPairs = Math.floor(filter.order * 0.5);
									const oddPoles = filter.order % 2 === 1;
									const poleInc = Math.PI / filter.order;
									filter.coefficients = new Float32Array((numPairs + oddPoles) * 11);

									// Odd order doesn't work since it requires first order filters
									// I only bothered implementing second order biquad filters
									let firstAngle = poleInc;
									if (oddPoles) {
										const co = getCoefficients(filter.type - 7, filter.freq, 0.5, dbGain);
										filter.coefficients.set(co, 0);
									} else {
										firstAngle *= 0.5;
									}
									
									// From https://www.earlevel.com/main/2016/09/29/cascading-filters/
									for (let i = 0; i < numPairs; ++i) {
										const Q = 1 / (2 * Math.cos(firstAngle + i * poleInc));
										const co = getCoefficients(filter.type - 7, filter.freq, Q, dbGain);
										filter.coefficients.set(co, (i + oddPoles) * 11);
									}
								} else {
									// Regular filter, store coefficients normally
									// [a0, a1, a2, b0, b1, b2, c0, c1, c2, c3, c4]
									filter.coefficients = getCoefficients(filter.type, filter.freq, filter.Q, dbGain);
								}
							}
							
							const filterOptions = [
								"Low Pass",
								"High Pass",
								"Band Pass",
								"Notch",
								"Peaking",
								"Low Shelf",
								"High Shelf",
								"Low Pass (Butterworth)",
								"High Pass (Butterworth)",
								"Band Pass (Butterworth)",
							];
							
							function addSelect(elem, text, filter, key, options) {
								const div = document.createElement("div");
								elem.appendChild(div);
								
								const label = document.createElement("label");
								label.textContent = text;
								div.appendChild(label);
								
								const typeSelect = document.createElement("select");
								for (let i = 0; i < options.length; ++i) {
									const option = document.createElement("option");
									option.text = options[i];
									option.value = i;
									typeSelect.add(option);
								}
								typeSelect.value = filter.type;
								typeSelect.addEventListener("change", function(e) {
									filter[key] = parseInt(e.target.value);
									disableElems(filter);
									updateCoefficients(filter);
									updateTimeResponse();
									updateFreqResponse();
									drawTime();
									drawFreq();
								});
								div.appendChild(typeSelect);
							}
							
							function addSlider(elem, text, min, max, step, filter, key, units) {
								filter.elems[key] = {};
								const div = document.createElement("div");
								elem.appendChild(div);
								filter.elems[key].div = div;
								
								const label = document.createElement("label");
								label.textContent = text;
								div.appendChild(label);
								
								const value = document.createElement("span");
								value.textContent = filter[key];
								label.appendChild(value);
								filter.elems[key].value = value;
								
								if (units) {
									const unit = document.createElement("span");
									unit.textContent = units;
									label.appendChild(unit);
								}
								
								const slider = document.createElement("input");
								slider.type = "range";
								slider.min = min;
								slider.max = max;
								slider.value = filter[key];
								slider.step = step;
								slider.addEventListener("input", function(e) {
									value.textContent = e.target.value;
									filter[key] = e.target.value;
									updateCoefficients(filter);
									updateTimeResponse();
									updateFreqResponse();
									drawTime();
									drawFreq();
								});
								div.appendChild(slider);
								filter.elems[key].slider = slider;
							}
							
							function addFilter() {
								const filter = {
									"type": filters.length <= 0 ? 0 : 4,
									"order": 4,
									"freq": Math.floor(Math.random() * nyquist * 1),
									"Q": 0.707,
									"dbGain": 6,
									"color": `hsl(${Math.floor(Math.random() * 360)}, 75%, 50%)`,
									"elems": {}
								};

								// Add new element
								const elem = document.createElement("div");
								elem.className = "biquad-filter position-relative d-flex flex-column flex-lg-row text-white rounded mb-2";
								elem.style.borderTop = `6px solid ${filter.color}`;
								filterListElem.appendChild(elem);
								
								// Add element contents
								addSelect(elem, "Type", filter, "type", filterOptions);
								addSlider(elem, "Frequency: ", 0, nyquist, 0.1, filter, "freq", " Hz");
								
								// Low pass, high pass, band pass, notch and peaking only
								addSlider(elem, "Q: ", 0.001, 8, 0.001, filter, "Q");
								
								// Peaking, high shelf and low shelf only
								addSlider(elem, "Gain: ", -dbScale, dbScale, 0.1, filter, "dbGain", " dB");
								
								// Butterworth only
								addSlider(elem, "Order: ", 2, 16, 2, filter, "order");
								
								disableElems(filter);
								updateCoefficients(filter);
								
								// Add delete button
								const close = document.createElement("button");
								close.className = "position-absolute end-0 top-0 mt-2 me-2 btn-close btn-close-white";
								close.addEventListener("mousedown", function() {
									elem.remove();
									const index = filters.indexOf(filter);
									if (index >= 0) {
										filters.splice(index, 1);
									}
									updateTimeResponse();
									updateFreqResponse();
									drawTime();
									drawFreq();
								});
								elem.appendChild(close);

								// Add new entry
								filters.push(filter);

								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							}

							canv.addEventListener("mousedown", function(e) {
								mouseClickData(e, canv, timeBefore, ampScale);
								
								updateDFT(freqBefore);
								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, timeBefore, ampScale);

								updateDFT(freqBefore);
								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							});

							canv2.addEventListener("mousedown", function(e) {
								activeFilter = getHoveredFilter(e);
								moveFilter(e);
							});

							canv2.addEventListener("mousemove", function(e) {
								if (activeFilter) {
									moveFilter(e);
								} else {
									hoveredFilter = getHoveredFilter(e);
									canv2.style.cursor = hoveredFilter ? "pointer" : "initial";
									drawFreq();
								}
							});

							canv2.addEventListener("mouseup", function(e) {
								activeFilter = undefined;
							});

							canv2.addEventListener("mouseleave", function(e) {
								activeFilter = undefined;
							});
							
							useDecibelsToggle.addEventListener("input", function(e) {
								useDecibels = e.target.checked;
								drawFreq();
							});

							linearPhaseToggle.addEventListener("input", function(e) {
								linearPhase = e.target.checked;
								filters.forEach(updateCoefficients);
								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							});
							
							addFilterElem.addEventListener("mousedown", addFilter);

							updateDFT(freqBefore);
							addFilter();
						})();
						</script>
						<p>Here's some ideas you can try:</p>
						<ul>
							<li>A lowpass filter dampens high frequencies. Try to dampen the noise without affecting the main sine wave.</li>
							<li>A highpass filter dampens low frequencies. Try to dampen the main sine wave without affecting the noise.</li>
							<li>A bandpass filter isolates a certain frequency. Try to isolate the main sine wave to cut the noise.</li>
							<li>A notch filter cuts out a certain frequency. Try to cut the main sine wave and identify its frequency.</li>
							<li>A peaking filter exaggerates or dampens a certain frequency. Try to exaggerate the main sine wave.</li>
							<li>A low shelf filter exaggerates or dampens low frequencies. Try to dampen the main sine wave.</li>
							<li>A high shelf filter exaggerates or dampens high frequencies. Try to exaggerate the noise.</li>
							<li>Butterworth filters are steeper, made by stacking default filters with certain settings. Try to isolate the main sine wave.</li>
						</ul>
						<h3>RBJ cookbook</h3>
						<p>So how do biquad filters work? Luckily they're well documented and have been studied for years.</p>
						<p>Maybe the most famous resource on biquad filters is <a href="https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html" target="_blank">Robert Bristow-Johnson's audio EQ cookbook</a>, which has a great <a href="https://www.musicdsp.org/en/latest/Filters/64-biquad-c-code.html" target="_blank">C version by Tom St Denis</a>. I used Tom's version for all my implementations, including my <a href="https://www.shadertoy.com/view/dtlSWH" target="_blank">GPU equalizer</a>.</p>
						<p>Though deriving the filters is complicated, running them is easy. It only takes 5 lines of code!</p>
						<pre><code class="language-js">result = a0 * sample
       + a1 * x1
       + a2 * x2
       - a3 * y1
       - a4 * y2

// Shift x1 to x2, sample to x1
x2 = x1;
x1 = sample;

// Shift y1 to y2, result to y1
y2 = y1;
y1 = result;</code></pre>
						<h3>Running this in Houdini</h3>
						<p>TODO</p>
						<div class="my-2">
							<a href="./hips/smoothing/biquad_equalizer.hipnc?raw=true" target="_blank">
								<button class="btn btn-primary"><i class="bi bi-download"></i> Download HIP file</button>
							</a>
						</div>
						<h2 id="method-4-fir-filters">Method 4: FIR filters</h2>
						<p>FIR filters are like if convolution and biquad filters had a baby. They're a type of convolution with a very powerful kernel.</p>
						<p>To understand them, let's go back to lerp. Remember how I said lerp is an IIR lowpass? What does IIR even mean?</p>
						<p>IIR stands for <b>Infinite Impulse Response</b>. This means the filter runs forever, and you keep feeding it samples infinitely. This is great for intense smoothing, since it gives plenty of time to move towards the target value. But most of the time we don't have infinite samples, like with Trail we only get a few samples at a time!</p>
						<p>You can't just chop a signal up, lerp each piece and expect consistent results.</p>
						<div>
							<canvas id="lerp4Canvas" width="640" height="200" style="cursor: pointer;"></canvas>
						</div>
						<div class="d-flex flex-column flex-sm-row mb-3 gap-3">
							<div>
								<div>
									<label for="lerp4Factor">Factor: </label>
									<span id="lerp4FactorValue"></span>
								</div>
								<input id="lerp4Factor" type="range" min="0" max="1" step="0.01" value="0.04">
							</div>
							<div>
								<input id="lerp4Linear" type="checkbox" checked>
								<label for="lerp4Linear">Linear Phase</label>
							</div>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("lerp4Canvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("lerp4Factor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("lerp4FactorValue");
							lerpValue.textContent = lerpFac;

							const linearPhaseToggle = document.getElementById("lerp4Linear");
							let linearPhase = linearPhaseToggle.checked;

							const data = generateData(Math.floor(canv.width * 0.5));
							const numCuts = Math.floor(canv.width * 0.01);
							const resetPeriod = Math.floor(data.length / numCuts);

							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#DD2020";
								drawData(canv, ctx, data, 1);
								
								if (linearPhase) {
									// Lerp forwards in time
									ctx.strokeStyle = "#808080";
									const dataCopy = data.slice();
									let current = dataCopy[0];
									for (let i = 0; i < dataCopy.length; ++i) {
										// Reset every cut
										if (i % resetPeriod === 0) {
											current = data[i];
											const xPos = i / (dataCopy.length - 1) * canv.width;
											drawLine(canv, ctx, xPos, 0, xPos, canv.height);
										}
										// The magic formula
										current = lerp(current, dataCopy[i], lerpFac);
										dataCopy[i] = current;
									}

									// Lerp backwards in time
									ctx.strokeStyle = "white";
									ctx.beginPath();
									current = dataCopy[dataCopy.length - 1];
									for (let i = dataCopy.length - 1; i >= 0; --i) {
										// Reset every cut
										if (i % resetPeriod === 0) {
											current = data[i];
											ctx.stroke();
											ctx.beginPath();
										}
										// The magic formula
										current = lerp(current, dataCopy[i], lerpFac);
										ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
									}
									ctx.stroke();
								} else {
									// Lerp forwards in time
									let current = data[0];
									ctx.strokeStyle = "white";
									ctx.beginPath();
									for (let i = 0; i < data.length; ++i) {
										// Reset every cut
										const xPos = i / (data.length - 1) * canv.width;
										if (i % resetPeriod === 0) {
											current = data[i];
											ctx.stroke();

											// Draw cut line
											ctx.strokeStyle = "#808080";
											const xPos = i / (data.length - 1) * canv.width;
											drawLine(canv, ctx, xPos, 0, xPos, canv.height);

											ctx.strokeStyle = "white";
											ctx.beginPath();

										}
										// The magic formula
										current = lerp(current, data[i], lerpFac);
										ctx.lineTo(xPos, (0.5 - current) * canv.height);
									}
									ctx.stroke();
								}
							}
							
							draw();

							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});

							canv.addEventListener("mousedown", function(e) {
								mouseClickData(e, canv, data, 1);
								draw();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, data, 1);
								draw();
							});

							linearPhaseToggle.addEventListener("input", function(e) {
								linearPhase = e.target.checked;
								draw();
							});
						})();
						</script>
						<p>This is why using Trail with IIR filters is a bad idea. It adds more lumps and jumps instead of smoothing them out. If only we could smooth pieces of a signal without getting so many nasty jumps. Turns out we can with FIR filters!</p>
						<p>FIR stands for <b>Finite Impulse Response</b>. In other words, the signal and filter have a fixed size. This is perfect for Trail!</p>
						<p>TODO: FINISH THIS</p>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>
