<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Time Smoothing</title>
		<meta name="description" content="Various ways to smooth and sharpen in Houdini.">
		<meta name="keywords" content="Lerp, Interpolation, Convolution, Kernel, Lowpass, Highpass, Bandpass, Allpass, Biquad, Filter, Smooth, Sharp">
		<meta property="og:title" content="Time Smoothing">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mysterypancake.github.io/Houdini-Fun/TimeSmoothing">
		<meta property="og:site_name" content="Time Smoothing">
		<meta property="og:description" content="Various ways to smooth and sharpen in Houdini.">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="./scripts/highlight.min.css">
		<script src="./scripts/highlight.min.js"></script>
		<link href="./scripts/bootstrap.min.css" rel="stylesheet">
		<script>
		// This uses requestFrame(), some browsers name it differently so this finds the best alternative
		const requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) { return window.setTimeout(e, 1000 / 60); };
		
		function lerp(a, b, factor) {
			return (1 - factor) * a + factor * b;
		}
		
		function invlerp(a, min, max) {
			return (a - min) / (max - min);
		}

		function clamp(x, min, max) {
			return Math.min(Math.max(x, min), max);
		}
		
		function gainTodB(gain) {
			// Clamp to prevent 0 gain
			gain = Math.max(gain, Number.MIN_VALUE);
			return 20.0 * Math.log10(gain);
		}
		
		function mouseClickData(e, canv, data, scale) {
			const key = Math.floor(e.offsetX / canv.width * (data.length - 1));
			data[key] = (0.5 - e.offsetY / canv.height) / scale;
		}

		// When drawing, replace entries which were drawn over between frames
		function mouseMoveData(e, canv, data, scale) {
			const lastKey = Math.floor((e.offsetX - e.movementX) / canv.width * (data.length - 1));
			const currentKey = Math.floor(e.offsetX / canv.width * (data.length - 1));
			
			const start = Math.min(lastKey, currentKey);
			const end = clamp(currentKey, lastKey, data.length - 1);
			
			for (let i = start; i <= end; ++i) {
				const pastValue = (e.offsetY + e.movementY * Math.sign(e.movementX));
				const line = start === end ? e.offsetY : lerp(e.offsetY, pastValue, invlerp(i, start, end));
				data[i] = (0.5 - line / canv.height) / scale;
			}
		}
		
		// Structured sine wave data
		function generateData(numPoints) {
			const data = new Float32Array(numPoints);
			for (let i = 0; i < numPoints; ++i) {
				const factor = i / numPoints;
				const sin = Math.sin(factor * 10) * 0.3;
				const noiseAmount = (Math.cos(factor * 15) + 1) * 0.2;
				const rand = Math.random() - 0.5;
				data[i] = sin + rand * noiseAmount;
			}
			return data;
		}
		
		// Completely random data
		function generateRandomData(numPoints) {
			const data = new Float32Array(numPoints);
			for (let i = 0; i < numPoints; ++i) {
				data[i] = Math.random();
			}
			return data;
		}

		// Gaussian kernel, not optimized for symmetry
		function gaussianKernel(numPoints) {
			// Dividing by 3 seems to scale the kernel the best
			let size = numPoints / 3;
			size *= size;

			let sum = 0;
			const kernel = new Float32Array(numPoints);
			const center = (numPoints - 1) * 0.5;

			for (let i = 0; i < numPoints; i++) {
				const x = i - center;
				kernel[i] = Math.exp(-x * x / size);
				sum += kernel[i];
			}

			// Normalize manually, no need for sqrt
			for (let i = 0; i < numPoints; i++) {
				kernel[i] /= sum;
			}
			return kernel;
		}

		function resizeCanvasWidth(elem) {
			elem.width = elem.parentElement.clientWidth;
		}

		function drawBackground(canv, ctx) {
			ctx.fillStyle = "#404040";
			ctx.fillRect(0, 0, canv.width, canv.height);
		}
		
		function drawLine(canv, ctx, x1, y1, x2, y2) {
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();
		}

		function drawConvolution(canv, ctx, data, kernelPos, weights, convAll) {
			const columnWidth = canv.width / (data.length - 1);
			const heightSplit = canv.height / 3;
			const middleWeight = Math.floor(weights.length * 0.5);

			ctx.fillStyle = "#505050";
			ctx.fillRect(kernelPos / (data.length - 1) * canv.width, 0, columnWidth * weights.length, canv.height)

			for (let i = 0; i < data.length; ++i) {
				const xPos = i / (data.length - 1) * canv.width;
				const height = data[i] * heightSplit * 0.5;

				// Draw top bars
				const topColor = `hsl(${i * 64}, 100%, 70%)`;
				ctx.fillStyle = topColor;
				ctx.fillRect(xPos, canv.height - heightSplit * 2 - height, columnWidth, height);

				// Draw middle bars
				ctx.fillStyle = "white";
				const offset = i - kernelPos;
				if (offset >= 0 && offset < weights.length) {
					ctx.fillStyle = "#707070";
					const height2 = weights[offset] * heightSplit * 0.5;
					ctx.fillRect(xPos, canv.height - heightSplit - height2, columnWidth, height2);

					ctx.fillStyle = topColor;
					const height3 = height2 * data[i];
					ctx.fillRect(xPos, canv.height - heightSplit - height3, columnWidth, height3);
				}

				// Draw bottom bars
				if (convAll || kernelPos + middleWeight === i) {
					let heightSum = canv.height;
					for (let j = 0; j < weights.length; ++j) {
						const height = data[clamp(i + j - middleWeight, 0, data.length - 1)] * weights[j] * heightSplit * 0.5;
						heightSum -= height;
						ctx.fillStyle = `hsl(${(i + j - middleWeight) * 64}, 100%, 70%)`;
						ctx.fillRect(xPos, heightSum, columnWidth, height);
					}
				}
			}
		}

		function drawData(canv, ctx, data, scale) {
			ctx.beginPath();
			for (let i = 0; i < data.length; ++i) {
				ctx.lineTo(i / (data.length - 1) * canv.width, (0.5 - data[i] * scale) * canv.height);
			}
			ctx.stroke();
		}

		function setup() {
			let list = document.getElementById("toc");
			const content = document.getElementById("content");
			const headings = content.querySelectorAll('h1, h2, h3, h4, h5, h6');
			const hash = window.location.hash.slice(1);
			let lastLevel = 0;
			let headingItems = [];
			
			headings.forEach(function(heading, index) {
				const level = parseInt(heading.tagName.slice(1));
				if (index === 0) {
					// First element, make a new list
					const childList = document.createElement("ul");
					list.appendChild(childList);
					list = childList;
				} else if (level > lastLevel) {
					// More indentation, make a new list per level
					for (let i = 0; i < level - lastLevel; ++i) {
						const childList = document.createElement("ul");
						list.appendChild(childList);
						list = childList;
					}
				} else if (level < lastLevel) {
					// Less indentation, move back a few levels
					for (let i = 0; i < lastLevel - level; ++i) {
						list = list.parentNode;
					}
				}
				
				let ref = `toc${index}`;
				if (heading.hasAttribute("id")) {
					ref = heading.getAttribute("id");
				} else {
					heading.setAttribute("id", ref);
				}
				
				const item = document.createElement("li");
				
				const link = document.createElement("a");
				link.setAttribute("href", `#${ref}`);
				link.textContent = heading.textContent;
				item.appendChild(link);
				
				list.appendChild(item);
				lastLevel = level;
				headingItems.push({ "link": link, "header": heading });

				// Scroll to linked heading
				if (ref === hash) {
					heading.scrollIntoView(true);
				}
			});
			
			const blurry = document.getElementById("blurryTitle");
			const title = blurry.textContent;
			blurry.textContent = "";
			
			const blurryLetters = [];
			for (let i = 0; i < title.length; ++i) {
				const span = document.createElement("span");
				span.textContent = title.charAt(i);
				const blurPixels = 4 - (i / title.length) * 4;
				span.style = `filter: blur(${blurPixels}px);`;
				blurry.appendChild(span);
				blurryLetters.push(span);
			}
			
			const intro = document.getElementById("intro");
			intro.addEventListener("mousemove", function(e) {
				for (let i = 0; i < blurryLetters.length; ++i) {
					const letter = blurryLetters[i];
					const bounds = letter.getBoundingClientRect();
					const blurPixels = Math.abs(bounds.x - e.clientX) * 0.01;
					letter.style = `filter: blur(${blurPixels}px);`;
				}
			});
			
			function updateNavigation() {
				let latestElem;
				headingItems.forEach(function(item) {
					item.link.classList.remove("active");
					if (item.header.getBoundingClientRect().top < 40) {
						latestElem = item;
					}
				});
				if (latestElem) {
					latestElem.link.classList.add("active");
				}
			}
			
			if (window.innerWidth >= 768) {
				window.addEventListener("scroll", updateNavigation);
				updateNavigation();
			}
			
			hljs.highlightAll();
		}
		</script>
		<style>
		#toc li a {
			color: black;
			display: block;
			text-decoration: none;
			transition: font-weight, padding 0.05s linear;
			width: 100%;
		}
		
		#toc li a:hover, #toc li a.active {
			padding-left: 0.5rem;
		}
		
		#toc li a.active {
			font-weight: bold;
			border-left: 2px solid black;
		}
		
		#toc ul {
			padding-left: 1rem;
			list-style-type: none;
		}
		
		#toc li {
			padding: 0.2rem 0rem;
		}
		
		#toc a.active {
			font-weight: bold;
		}

		h2, h3, h4, h5, h6 {
			margin-top: 1.5rem;
			margin-bottom: 1rem;
		}
		
		.biquad-filter > div, .biquad-filter select, .biquad-filter input {
			width: 100%;
		}

		.biquad-filter {
			background-color: #404040;
			column-gap: 1rem;
			row-gap: 0.5rem;
			padding: 1.2rem;
		}
		</style>
	</head>
	<body onload="setup();">
		<div class="container mt-5">
			<div class="row">
				<div class="col-md-3 d-none d-md-block">
					<nav id="toc" class="sticky-top pt-3"></nav>
				</div>
				<div class="col-md-9">
					<section id="intro">
						<h1 id="blurryTitle" class="mb-4">Smoothing and sharpening in time</h1>
						<p>This was inspired by a talk <a href="https://www.linkedin.com/feed/update/urn:li:activity:7159079030745452544/" target="_blank">Catherine Williams did at SydHUG</a>. She looked into a bunch of equations to smooth data, then used them to smooth jittery cloth sims over time.</p>
						<p>Smoothing and sharpening is a pretty cool topic I've dipped into into a few times, so I wanted to gather some popular methods and dump them into Houdini in case it helps someone. If you're Catherine this is probably old news, but hopefully it's fun anyway!</p>
						<p>For some reason Houdini doesn't have many built-in nodes for time smoothing. Unreal Engine, Blender and Maya have plenty of ways, like Butterworth and Chebyshev filters. These are super popular for motion capture, which always comes in janky.</p>
						<p><b>EDIT:</b> Matt Estela mentioned the <a href="https://www.sidefx.com/docs/houdini/nodes/sop/kinefx--smoothmotion.html" target="_blank">Smooth Motion</a> node, which it turns out runs on points too. It works as a built-in Butterworth filter. Pretty handy!</p>
						<p><b>EDIT 2:</b> Harrison Molling mentioned CHOPs, which have <a href="https://www.sidefx.com/docs/houdini/nodes/chop/filter.html" target="_blank">Filter</a> and <a href="https://www.sidefx.com/docs/houdini/nodes/chop/pass.html" target="_blank">Pass Filter</a> nodes. Forget what I said before!</p>
						<p>Still, there's many filters we can't get in SOPs (like convolution), and it's good to learn for more control. Let's start with lerp!</p>
					</section>
					<div id="content">
						<h2>Method 1: Lerp</h2>
						<p>The easiest way to smooth stuff is with lerp, <a href="./Lerp" target="_blank">which I wrote about here</a>. It's really popular for games, especially in Unity. It's not a good method, but it's a nice intro to the topic.</p>
						<p>The idea is you start at some value, then pick a target value. Each frame you move a little bit closer to the target by some percentage. The slower you move, the smoother your path becomes.</p>
						<pre><code class="language-js">current = lerp(current, target, factor);</code></pre>
						<p>Here's a demo with the smooth version in white. Click and drag to draw your own data.</p>
						<div>
							<canvas id="lerpCanvas" width="640" height="200" style="cursor: pointer;"></canvas>
						</div>
						<div>
							<canvas id="lerpLiveCanvas" width="640" height="32"></canvas>
						</div>
						<div class="mb-3">
							<label for="lerpFactor">Factor</label>
							<input id="lerpFactor" type="range" min="0" max="1" step="0.01" value="0.1">
							<span id="lerpFactorValue"></span>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("lerpCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("lerpFactor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("lerpFactorValue");
							lerpValue.textContent = lerpFac;

							const data = generateData(Math.floor(canv.width * 0.5));
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#DD2020";
								drawData(canv, ctx, data, 1);
								
								ctx.strokeStyle = "white";
								ctx.beginPath();
								let current = data[0];
								for (let i = 0; i < data.length; ++i) {
									// The magic formula
									current = lerp(current, data[i], lerpFac);
									ctx.lineTo(i / (data.length - 1) * canv.width, (0.5 - current) * canv.height);
								}
								ctx.stroke();
							}
							
							draw();

							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});

							canv.addEventListener("click", function(e) {
								mouseClickData(e, canv, data, 1);
								draw();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, data, 1);
								draw();
							});

							const canv2 = document.getElementById("lerpLiveCanvas");
							const ctx2 = canv2.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv2);

							let target = Math.random() * (canv2.width - canv2.height);
							let current = 0;

							function drawLive() {
								drawBackground(canv2, ctx2);

								const blockSize = canv2.height * 0.5;

								// Draw target value
								ctx2.fillStyle = "#FF0000";
								ctx2.fillRect(target, blockSize * 0.5, blockSize, blockSize);

								// Draw current value
								ctx2.fillStyle = "white";
								ctx2.fillRect(current, blockSize * 0.5, blockSize, blockSize);

								// The magic formula
								current = lerp(current, target, lerpFac);

								requestFrame(drawLive);
							}

							requestFrame(drawLive);

							let hovering = false;

							canv2.addEventListener("mouseenter", function(e) {
								hovering = true;
							});

							canv2.addEventListener("mouseleave", function(e) {
								hovering = false;
							});

							// Move target to new position
							window.setInterval(function() {
								if (hovering) return;
								target = Math.random() * (canv2.width - canv2.height);
							}, 1000);

							canv2.addEventListener("mousemove", function(e) {
								target = e.offsetX;
							});
						})();
						</script>
						<p>There's 3 big problems with this method, which all smoothing methods suffer from.</p>
						<h3>Problem 1: Phase shift</h3>
						<p>If you set the slider really low, it looks like the graph moves to the right. This is called <b>phase shift</b>.</p>
						<p>It happens since the value is too lazy in moving to the target, so it sticks near the previous value and smears out the graph.</p>
						<p>Phase shift is a popular topic in music, you'll find many audio engineers rambling about it online (<a href="https://www.youtube.com/@DanWorrall" target="_blank">Dan Worrall</a> is my favourite). When you use an equalizer on music (for example to boost the bass), it usually adds a bit of phase shift. Some plugins (like <a href="https://ddmf.eu/plugindoctor/" target="_blank">Plugindoctor</a>) even show you the exact phase shift you'll get. This is called the <b>phase response</b>.</p>
						<p>Phase shift is a natural part of the universe so there's nothing wrong with it, but it's annoying if you want stuff to line up. The lazy way is shifting over the graph. The proper way is using <b>linear phase</b> filters. Linear phase filters always need values forwards in time as well as backwards.</p>
						<p>Apparently if you <a href="https://www.youtube.com/watch?v=eSyCuuSzuE4" target="_blank">smooth forwards then again in reverse</a>, it cancels out the phase shift and makes a linear phase filter. Here's a demo with the linear version in green.</p>
						<div>
							<canvas id="lerp3Canvas" width="640" height="200" style="cursor: pointer;"></canvas>
						</div>
						<div class="mb-3">
							<label for="lerp3Factor">Factor</label>
							<input id="lerp3Factor" type="range" min="0" max="1" step="0.01" value="0.02">
							<span id="lerp3FactorValue"></span>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("lerp3Canvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("lerp3Factor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("lerp3FactorValue");
							lerpValue.textContent = lerpFac;

							const data = generateData(Math.floor(canv.width * 0.5));
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#808080";
								drawData(canv, ctx, data, 1);
								
								ctx.strokeStyle = "#FF0000";
								ctx.beginPath();

								// Lerp forwards in time
								const dataCopy = data.slice();
								let current = dataCopy[0];
								for (let i = 0; i < dataCopy.length; ++i) {
									// The magic formula
									current = lerp(current, dataCopy[i], lerpFac);
									ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
									dataCopy[i] = current;
								}

								ctx.stroke();

								ctx.strokeStyle = "#00FF00";
								ctx.beginPath();

								// Lerp backwards in time
								current = dataCopy[dataCopy.length - 1];
								for (let i = dataCopy.length - 1; i >= 0; --i) {
									// The magic formula
									current = lerp(current, dataCopy[i], lerpFac);
									ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
								}

								ctx.stroke();
							}
							
							draw();

							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});

							canv.addEventListener("click", function(e) {
								mouseClickData(e, canv, data, 1);
								draw();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, data, 1);
								draw();
							});
						})();
						</script>

						<h3>Problem 2: Oversmoothing</h3>
						<p>You'll find this method is hard to control. It tends to smooth everything too much or not enough.</p>
						<p>This is because of the <b>order</b> of the filter. The order basically means how sharp and precise a filter is. Here's a nice diagram from <a href="https://www.electronics-tutorials.ws/filter/filter_8.html" target="_blank">Electronics Tutorials</a>. You can see as the order increases the curve gets steeper, meaning it cuts precisely and doesn't smudge everything.</p>
						<img src="./images/smoothing/filterorder.gif" class="mb-3 mw-100">
						<p>The lerp method is a <a href="https://tomroelandts.com/articles/low-pass-single-pole-iir-filter" target="_blank">first order IIR lowpass</a>, so it's pretty blunt and tends to smudge everything out.</p>
						<p>Turns out there's a cool trick to improve it. If you stack a bunch of low order filters, you approximate a high order filter. This works surprisingly well, though it's much slower and smudgier than doing it properly.</p>
						<p>Here's a demo with the original filter in red, and the layered filters coloured towards purple. Try drawing some data and watch it move!</p>
						<div>
							<canvas id="lerp2Canvas" width="640" height="200" style="cursor: pointer;"></canvas>
						</div>
						
						<!--<table class="mb-3">
							<tr>
								<td class="pe-3">
									
								</td>
								<td class="pe-3">
									
								</td>
								<td>
									
								</td>
							</tr>
							<tr>
								<td class="pe-3">
									
								</td>
								<td class="pe-3">
									
								</td>
							</tr>
						</table>-->
						<div class="d-flex flex-column flex-sm-row mb-3 gap-3">
							<div>
								<div>
									<label for="lerp2Factor">Factor:</label>
									<span id="lerp2FactorValue"></span>
								</div>
								<input id="lerp2Factor" type="range" min="0" max="1" step="0.01" value="0.1">
							</div>
							<div>
								<div>
									<label for="lerp2Layers">Layers:</label>
									<span id="lerp2LayersValue"></span>
								</div>
								<input id="lerp2Layers" type="range" min="1" max="50" step="1" value="10">
							</div>
							<div>
								<input id="lerp2Linear" type="checkbox">
								<label for="lerp2Linear">Linear Phase</label>
							</div>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("lerp2Canvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("lerp2Factor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("lerp2FactorValue");
							lerpValue.textContent = lerpFac;

							const layersSlider = document.getElementById("lerp2Layers");
							let lerpLayers = parseFloat(layersSlider.value);

							const layersValue = document.getElementById("lerp2LayersValue");
							layersValue.textContent = lerpLayers;

							const linearToggle = document.getElementById("lerp2Linear");
							let linearPhase = linearToggle.checked;

							const data = generateData(Math.floor(canv.width * 0.5));
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#808080";
								drawData(canv, ctx, data, 1);

								// Chain the crappy lowpass filter to approximate a higher order lowpass filter
								const dataCopy = data.slice();
								for (let j = 0; j < lerpLayers; ++j) {

									ctx.strokeStyle = `hsl(${j / lerpLayers * 360}, 100%, 70%)`;
									ctx.beginPath();

									// Lerp forwards in time
									let current = dataCopy[0];
									for (let i = 0; i < dataCopy.length; ++i) {
										// The magic formula
										current = lerp(current, dataCopy[i], lerpFac);
										if (!linearPhase) {
											ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
										}
										dataCopy[i] = current;
									}

									// Lerp backwards in time
									if (linearPhase) {
										current = dataCopy[dataCopy.length - 1];
										for (let i = dataCopy.length - 1; i >= 0; --i) {
											// The magic formula
											current = lerp(current, dataCopy[i], lerpFac);
											ctx.lineTo(i / (dataCopy.length - 1) * canv.width, (0.5 - current) * canv.height);
											dataCopy[i] = current;
										}
									}
									ctx.stroke();
								}
							}
							
							draw();
							
							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});
							
							layersSlider.addEventListener("input", function(e) {
								lerpLayers = parseFloat(e.target.value);
								layersValue.textContent = lerpLayers;
								draw();
							});

							linearToggle.addEventListener("input", function(e) {
								linearPhase = e.target.checked;
								draw();
							});

							canv.addEventListener("click", function(e) {
								mouseClickData(e, canv, data, 1);
								draw();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								mouseMoveData(e, canv, data, 1);
								draw();
							});
						})();
						</script>
						<h3>Problem 3: Undershooting</h3>
						<p>When the slider is below 1, it never actually reaches the target.</p>
						<p>You can tell from the formula. Lerp takes a percentage of two values and adds them together <a href="./Lerp" target="_blank">as described here</a>. For example if the factor is 0.9, it takes 10% of the current value and adds on 90% of the target value. That means you never get 100% of the target.</p>
						<p>Here's a demo where the white line targets the red line. Though it may appear to, it always lies below the red line until the factor is 1.</p>
						<div>
							<canvas id="undershootCanvas" width="640" height="200"></canvas>
						</div>
						<div class="mb-3">
							<label for="undershootFactor">Factor</label>
							<input id="undershootFactor" type="range" min="0" max="1" step="0.01" value="0.1">
							<span id="undershootFactorValue"></span>
						</div>
						<script>
						(function(){
							const canv = document.getElementById("undershootCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const lerpSlider = document.getElementById("undershootFactor");
							let lerpFac = parseFloat(lerpSlider.value);

							const lerpValue = document.getElementById("undershootFactorValue");
							lerpValue.textContent = lerpFac;
							
							function draw() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#FF0000";
								drawLine(canv, ctx, 0, canv.height * 0.2, canv.width, canv.height * 0.2);
								
								ctx.strokeStyle = "white";
								ctx.beginPath();
								let current = 0.8;
								for (let i = 0; i <= canv.width; i += 8) {
									// The magic formula
									current = lerp(current, 0.2, lerpFac);
									ctx.lineTo(i, current * canv.height);
								}
								ctx.stroke();
							}
							
							draw();
							
							lerpSlider.addEventListener("input", function(e) {
								lerpFac = parseFloat(e.target.value);
								lerpValue.textContent = lerpFac;
								draw();
							});
						})();
						</script>
						<h3>Running this in Houdini</h3>
						<p>To get this into Houdini, we need a way to access the previous frame. Luckily there's many ways to do this.</p>
						<h4>Option 1: Solver</h4>
						<p>I prefer using a Solver since it's the most robust. It runs in sequence so it's guaranteed not to skip any frames, so if you had a huge jolt it continues smoothing out the impact 1000 frames later. Audio plugins also run in sequence, so we can steal their code and be sure the result is the same. This comes in handy later!</p>
						<p>First add a Solver node, then a Point Wrangle inside. Plug the the current animation (Input_1) into the second wrangle input.</p>
						<img src="./images/smoothing/lerpwrangle.PNG" width="640" class="mb-3 mw-100">
						<p>Now we can write the formula in VEX. In solvers, <code>@P</code> is the current position. The second input we connected <code>@opinput1_P</code> is the latest animation, which is our target position.</p>
						<pre><code class="language-js">v@P = lerp(v@P, v@opinput1_P, chf("factor"));</code></pre>
						<p>Here's before and after. It smooths out most of the noise, but reduces the range of motion too much.</p>
						<img src="./images/smoothing/lerpsmoothsolver.gif" width="640" class="mw-100">
						<p>
							<a href="./hips/smoothing/lerp_smooth_solver.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<p>Although solvers are more robust, to get linear phase we'd have to chain a bunch of solvers in a row. We can avoid this with Trail.</p>
						<h4>Option 2: Trail</h4>
						<p>Instead of sampling all past frames, it's faster to sample a handful of past frames and try to guess the future from them. This is called a <b>sliding window</b> technique, which Catherine used for her demo. It's good for production since it can be batch processed and run in parallel. <a href="https://www.shadertoy.com/view/dtlSWH" target="_blank">I used it to make a GPU equalizer</a>. However it's inaccurate for lerp-based smoothing, since it ignores jolts if it has no idea they happened.</p>
						<p>To try it, add a Trail node and a Point Wrangle. Plug the trail into the second wrangle input.</p>
						<img src="./images/smoothing/trailwrangle.PNG" width="640" class="mb-3 mw-100">
						<p>For dense meshes, it helps to cache the trail for better performance.</p>
						<p>Now we need to extract positions from different frames. This is done using <code>point()</code>. It has 3 arguments, but we only care about the last one.</p>
						<pre><code class="language-js">vector pos = point(0, "P", point_number);</code></pre>
						<p>Given the current point number <code>@ptnum</code>, we need to find the matching point number on the previous frame. Assuming the topology stays the same, you'll find a pattern. Let's say your <code>@ptnum</code> is 0. If the mesh has 5 points, your <code>@ptnum</code> on the previous frame will be 5, 10, 15, 20 and so on. This happens since the Trail node merges batches of 5 points per frame.</p>
						<p>Using <code>npoints(0)</code> to get the number of points in the mesh, the general formula is <code>@ptnum + npoints(0) * frame</code></p>
						<img src="./images/smoothing/trailframes.png" class="mb-3 w-100">
						<p>Using this idea we can lerp through the positions from past to present, just like with the solver. No dictionaries or maps required!</p>
						<pre><code class="language-js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);

// Start at the last frame's position (the oldest frame)
v@P = point(1, "P", i@ptnum + point_count * (trail_length - 1));

// Lerp from the past to the present, like the solver except manually
for (int frame = 1; frame &lt; trail_length; ++frame) {
	// Get the corresponding point position on the next frame
	vector target_pos = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
	// The magic formula
	v@P = lerp(v@P, target_pos, chf("factor"));
}</code></pre>
						<p>Here's before and after. It looks pretty similar, but jitters more since it keeps forgetting past samples.</p>
						<img src="./images/smoothing/lerpsmoothtrail.gif" width="640" class="mw-100">
						<p>
							<a href="./hips/smoothing/lerp_smooth_trail.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<p>Sadly this version suffers from phase shift, just like the solver. The great thing with Trail is it doesn't have to. We can make linear phase filters and stack them too!</p>
						<h5>Linear phase version</h5>
						<p>First we need a way to get frames forwards in time as well as backwards. This is as easy as adding a Time Shift node after Trail.</p>
						<img src="./images/smoothing/trailtimeshift.png" width="640" class="mb-3 mw-100">
						<p>Set the frame offset to <code>$F + (ch("../trail1/length") - 1) / 2</code>. This centers the current frame, so we have the same number of frames forwards and backwards in time.</p>
						<img src="./images/smoothing/trailframeoffset.png" width="860" class="mb-3 mw-100">
						<p>Next we can reuse the same frame offset idea from before, except this time filtering in both directions.</p>
						<pre><code class="language-js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);
float factor = chf("factor");
int layers = chi("layers");

// Build an array of all positions on all frames
// For optimization, you could do a forward lerp in here
vector pos[];
resize(pos, trail_length);
for (int frame = 0; frame < trail_length; ++frame) {
	pos[frame] = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
}

// Smooth a bunch of times in a row (if you want)
for (int i = 0; i < layers; ++i) {

	// Smooth forwards in time
	vector current_pos = pos[0];
	for (int frame = 1; frame < trail_length; ++frame) {
		// The magic formula
		pos[frame] = lerp(current_pos, pos[frame], factor);
		current_pos = pos[frame];
	}

	// Smooth backwards in time
	current_pos = pos[trail_length - 1];
	for (int frame = trail_length - 2; frame >= 0; --frame) {
		// The magic formula
		pos[frame] = lerp(current_pos, pos[frame], factor);
		current_pos = pos[frame];
	}
}

// Get the center frame, which is our frame
v@P = pos[trail_length / 2];</code></pre>
						<p>Thanks to looking into the future, we can anticipate motion before it even happens. Here's a demo with the linear phase version in green and the original version in red.</p>
						<img src="./images/smoothing/lerpsmoothtraillinear.gif" width="540" class="mw-100">
						<p>
							<a href="./hips/smoothing/lerp_smooth_trail_linear.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<p>While lerp works OK, there's plenty of fancier methods of smoothing out stuff. Let's learn about convolution!</p>
						<h2>Method 2: Convolution</h2>
						<p>Convolution solves many problems we were having before. It's practically linear phase and only needs a handful of frames, making it perfect for batch processing. It's a weighted sum just like lerp, but it's much more powerful than you'd expect. It works for smoothing, sharpening, embossing and all kinds of cool filters.</p>
						<p>It works by picking a value, sampling the neighbours around it, multiplying them and adding them together. It's like what we did with lerp, except now we have precise control over how much each neighbour contributes to the final result. We can totally ignore neighbours or even flip their influence.</p>
						<p>For example, say you want each value to be the average of its 2 neighbours. For that you can use the kernel <code>[0.5, 0, 0.5]</code>.</p>
						<img src="./images/smoothing/convolution.png" width="640" class="mb-3 mw-100">
						<p>Here we sample 9's neighbours (4 and 6), then calculate <code>4 * 0.5 + 9 * 0 + 6 * 0.5 = 5</code>. In other words, ignore 9 and average 4 and 6 together.</p>
						<p>The key idea of convolution is you can slide the kernel up and down. Click and drag to see what I mean!</p>
						<div>
							<canvas id="convCanvas" width="720" height="360" style="cursor: pointer;"></canvas>
						</div>
						<table class="mb-3">
							<tr class="text-center">
								<td class="pe-3">
									<span id="convXWeightValue"></span>
								</td>
								<td class="pe-3">
									<span id="convYWeightValue"></span>
								</td>
								<td class="pe-3">
									<span id="convZWeightValue"></span>
								</td>
								<td>
									<input id="convAll" type="checkbox">
									<label for="convAll">Convolve All</label>
								</td>
							</tr>
							<tr>
								<td class="pe-3">
									<input id="convXWeight" type="range" min="0" max="1" step="0.1" value="0.5">
								</td>
								<td class="pe-3">
									<input id="convYWeight" type="range" min="0" max="1" step="0.1" value="0">
								</td>
								<td class="pe-3">
									<input id="convZWeight" type="range" min="0" max="1" step="0.1" value="0.5">
								</td>
							</tr>
						</table>
						<script>
						(function(){
							const canv = document.getElementById("convCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const xSlider = document.getElementById("convXWeight");
							let xWeight = parseFloat(xSlider.value);

							const xValue = document.getElementById("convXWeightValue");
							xValue.textContent = xWeight;

							const ySlider = document.getElementById("convYWeight");
							let yWeight = parseFloat(ySlider.value);

							const yValue = document.getElementById("convYWeightValue");
							yValue.textContent = yWeight;

							const zSlider = document.getElementById("convZWeight");
							let zWeight = parseFloat(zSlider.value);

							const zValue = document.getElementById("convZWeightValue");
							zValue.textContent = zWeight;

							const convToggle = document.getElementById("convAll");
							let convAll = convToggle.checked;

							const data = generateRandomData(Math.floor(canv.width / 16));
							let kernelPos = Math.floor(data.length * 0.5);

							let weights;
							function updateWeights() {
								weights = [xWeight, yWeight, zWeight];
							}
							updateWeights();

							function draw() {
								drawBackground(canv, ctx);
								drawConvolution(canv, ctx, data, kernelPos, weights, convAll);
							}

							draw();

							xSlider.addEventListener("input", function(e) {
								xWeight = parseFloat(e.target.value);
								xValue.textContent = xWeight;
								updateWeights();
								draw();
							});

							ySlider.addEventListener("input", function(e) {
								yWeight = parseFloat(e.target.value);
								yValue.textContent = yWeight;
								updateWeights();
								draw();
							});

							zSlider.addEventListener("input", function(e) {
								zWeight = parseFloat(e.target.value);
								zValue.textContent = zWeight;
								updateWeights();
								draw();
							});

							convToggle.addEventListener("input", function(e) {
								convAll = e.target.checked;
								draw();
							});

							function moveKernel(e) {
								kernelPos = Math.round(e.offsetX / canv.width * (data.length - 1) - weights.length * 0.5);
								draw();
							}

							canv.addEventListener("click", moveKernel);
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								moveKernel(e);
							});
						})();
						</script>
						<p>Tick "Convolve All" to see the full convolution, then mess with the weights to see what you find! Here's a few you can try:</p>
						<ul>
							<li>The kernel <code>[1, 0, 0]</code> shifts everything 1 unit to the right.</li>
							<li>The kernel <code>[0, 0, 1]</code> shifts everything 1 unit to the left.</li>
							<li>The kernel <code>[0, 1, 0]</code> keeps everything the same.</li>
							<li>The kernel <code>[1, 1, 1]</code> sums all 3 values together.</li>
							<li>The kernel <code>[1, 1, 0]</code> sums the previous and current value.</li>
							<li>The kernel <code>[0, 1, 1]</code> sums the current and next value.</li>
							<li>The kernel <code>[1, 0, 1]</code> sums both neighbours.</li>
							<li>The kernel <code>[0.5, 0, 0.5]</code> averages the two neighbours together.</li>
							<li>The kernel <code>[0.5, 0.5, 0]</code> averages the previous and current value.</li>
							<li>The kernel <code>[0, 0.5, 0.5]</code> averages the current and next value.</li>
						</ul>
						<p>With a tiny size 3 kernel, we can already do so many things. Hopefully this gives you an idea of how powerful and versatile convolution is.</p>
						<h3>Gaussian blur</h3>
						<p>Gaussian blur is one of the many things we can do with convolution. We just need to replace our kernel with a gaussian kernel. It looks like this.</p>
						<img src="./images/smoothing/gaussiankernel.png" width="512" class="mb-3 mw-100">
						<p>Stripping the formula to the bones, you can write it as <code>exp(-x * x / (size * size))</code>, where <code>x</code> is the value and <code>size</code> is the width of the shape. It extends infinitely, so you need to pick a size that fits most of it between -1 and 1. I found dividing <code>size</code> by 3 works pretty well, or in other words <code>exp(-9 * x * x / (size * size))</code>. Then we normalize it so all values add to 1.</p>
						<p>And just like that we have gaussian blur! Change the kernel size to set the intensity.</p>
						<div>
							<canvas id="gaussianCanvas" width="720" height="360" style="cursor: pointer;"></canvas>
						</div>
						<table class="mb-3">
							<tr>
								<td class="pe-3">
									<label for="gaussSize">Kernel Size:</label>
									<span id="gaussSizeValue"></span>
								</td>
								<td>
									<input id="gaussConvAll" type="checkbox" checked>
									<label for="gaussConvAll">Convolve All</label>
								</td>
							</tr>
							<tr>
								<td class="pe-3">
									<input id="gaussSize" type="range" min="1" max="65" step="2" value="5">
								</td>
							</tr>
						</table>
						<script>
						(function(){
							const canv = document.getElementById("gaussianCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);

							const convToggle = document.getElementById("gaussConvAll");
							let convAll = convToggle.checked;

							const sizeSlider = document.getElementById("gaussSize");
							let gaussSize = parseInt(sizeSlider.value);

							const sizeValue = document.getElementById("gaussSizeValue");
							sizeValue.textContent = gaussSize;

							const data = generateRandomData(Math.floor(canv.width / 16));
							let kernelPos = Math.floor(data.length * 0.5);
							let weights = gaussianKernel(5);

							function draw() {
								drawBackground(canv, ctx);
								drawConvolution(canv, ctx, data, kernelPos, weights, convAll);
							}

							draw();

							convToggle.addEventListener("input", function(e) {
								convAll = e.target.checked;
								draw();
							});

							sizeSlider.addEventListener("input", function(e) {
								gaussSize = parseInt(e.target.value);
								sizeValue.textContent = gaussSize;
								weights = gaussianKernel(gaussSize);
								draw();
							});

							function moveKernel(e) {
								kernelPos = Math.round(e.offsetX / canv.width * (data.length - 1) - weights.length * 0.5);
								draw();
							}

							canv.addEventListener("click", moveKernel);
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								moveKernel(e);
							});
						})();
						</script>
						<h3>Running this in Houdini</h3>
						<p>To get this into Houdini, we can reuse the trail setup from the lerp section with a few minor changes.</p>
						<p>First we need to make the kernel. We can do it in a Detail Wrangle since it never changes and only needs to be built once.</p>
						<img src="./images/smoothing/detailwrangle.png" width="640" class="mb-3 mw-100">
						<p>Let's store the kernel in a detail attribute. The syntax is pretty ugly, <code>f[]@kernel</code> just means an array of floats.</p>
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");

// Width of shape, divided by 3 so it fits snugly between -1 and 1
float size = trail_length / 3.0;

// Preallocate array size
resize(f[]@kernel, trail_length);
f@kernel_sum = 0;

// Build guassian kernel (array of floats)
for (int i = 0; i < trail_length; ++i) {
	// Center it on the middle value
	float x = i - (trail_length - 1) / 2.0;
	f[]@kernel[i] = exp(-x * x / (size * size));
	f@kernel_sum += f[]@kernel[i];
}</code></pre>
						<p>Now we dump in the Trail, Time Shift and Point Wrangle from the lerp section. Like before, the frame offset is <code>$F + (ch("../trail1/length") - 1) / 2</code>.</p>
						<img src="./images/smoothing/detailwrangle2.png" width="640" class="mb-3 mw-100">
						<p>Now onto the convolution. It's surprisingly easy since Trail and Time Shift did the hard work for us. We just need to add up all the values multiplied by their respective weights.</p>
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);

// Convolve all frames to get the current frame
vector pos_total = 0;
for (int frame = 0; frame < trail_length; ++frame) {
	vector pos = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
	pos_total += pos * f[]@kernel[frame];
}

// Normalize so it adds to 1
v@P = pos_total / f@kernel_sum;</code></pre>
						<p>The trail length directly controls the amount of blur. The more frames we sample, the more we can blur.</p>
						<table class="text-center">
							<tr>
								<th>23 frames</th>
								<th>61 frames</th>
							</tr>
							<tr>
								<td>
									<img src="./images/smoothing/convolutiontrail.gif" width="640" class="mw-100">
								</td>
								<td>
									<img src="./images/smoothing/convolutiontrail2.gif" width="640" class="mw-100">
								</td>
							</tr>
						</table>
						<p>
							<a href="./hips/smoothing/convolution_smoothing.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<p>Now I know what you're thinking. This looks exactly like the lerp method from before! What's the point of going through all that effort?</p>
						<p>Well firstly, it properly reaches the target unlike the lerp method. And secondly, you can swap out the kernel to get cool effects!</p>
						<h4>Cool kernels</h4>
						<p>Here's a cool kernel I made by accident. It turns any animation into an incredible springy mess!</p>
						<img src="./images/smoothing/springykernel.png" width="960" class="mb-3 mw-100">
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");

// Preallocate array size
resize(f[]@kernel, trail_length);
f@kernel_sum = 0;

// Build insane kernel
float insanity = 2;
for (int i = 0; i < trail_length; ++i) {
	// Center it on the middle value
	float x = i - (trail_length - 1) / 2.0;
	// Normalize the range
	x /= trail_length;
	// Invoke madness
	f[]@kernel[i] = cos(2 * PI * x) * (insanity - abs(x));
	f@kernel_sum += f[]@kernel[i];
}</code></pre>
						<img src="./images/smoothing/convolutionspringy.gif" width="640" class="mw-100">
						<p>
							<a href="./hips/smoothing/convolution_springy.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<p>These formulas are a pain to set up though. It'd be nice if we could control the kernel visually, maybe with a ramp.</p>
						<p>Since the ramp stores the kernel for us, we can delete the Detail Wrangle and just use the Point Wrangle.</p>
						<pre><code language="js">// Make sure this matches your trail node
int trail_length = chi("../trail1/length");
int point_count = npoints(0);

// Convolve all frames to get the current frame
vector pos_total = 0;
float kernel_sum = 0;

for (int frame = 0; frame < trail_length; ++frame) {
	vector pos = point(1, "P", i@ptnum + point_count * (trail_length - 1 - frame));
	float weight = chramp("kernel", float(frame) / (trail_length - 1));
	pos_total += pos * weight;
	kernel_sum += weight;
}

// Normalize so it adds to 1
if (chi("normalize_kernel")) {
	pos_total /= kernel_sum;
}

v@P = pos_total;</code></pre>
						<h4>Sharp kernels</h4>
						<p>Sharpening kernels are usually positive in the middle and negative on the sides. Here's one I drew to exaggerate the motion.</p>
						<img src="./images/smoothing/sharpenramp.png" width="860" class="mb-3 mw-100">
						<table class="text-center">
							<tr>
								<th>15 frames</th>
								<th>35 frames</th>
							</tr>
							<tr>
								<td>
									<img src="./images/smoothing/convolutioncustom.gif" width="640" class="mw-100">
								</td>
								<td>
									<img src="./images/smoothing/convolutioncustom2.gif" width="640" class="mw-100">
								</td>
							</tr>
						</table>
						<p>
							<a href="./hips/smoothing/convolution_custom.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<h4>Blurry kernels</h4>
						<p>We can make blurry kernels too, just like before. To make box blur (also called a moving average), just draw a flat line.</p>
						<img src="./images/smoothing/boxblur.png" width="860" class="mb-3 mw-100">
						<p>To approximate gaussian blur, draw a bell curve centered at 0.5.</p>
						<img src="./images/smoothing/gaussianblur.png" width="860" class="mb-3 mw-100">
						<p>Here's a demo with gaussian blur in blue and box blur in green. Box blur tends to blur more aggressively since it uses all samples equally.</p>
						<img src="./images/smoothing/convolutionblurs.gif" width="640" class="mw-100">
						<p>
							<a href="./hips/smoothing/convolution_blurs.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<p>For another type of exaggeration, draw a ramp from negative to positive or vice-versa.</p>
						<img src="./images/smoothing/rampkernel.png" width="860" class="mb-3 mw-100">
						<p>TODO: ADD DEMO AND HIP FILE</p>
						<h3>Topology convolution</h3>
						<p>Going off track for a bit, I started wondering what happens if you convolve geometry instead of time.</p>
						<p>Convolution just needs neighbours and weights. Let's sample a bunch of nearby points, multiply them by weights and add them together. Just like Attribute Blur, we could do it by connectivity or proximity.</p>
						<p>
							<a href="./hips/smoothing/convolution_topology.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
						<h4>Option 1: Connectivity</h4>
						<p>If the geometry is connected by edges, we can weigh each point by how many edges away it is from the current point.</p>
						<p>For example, TODO: ADD LINE DIAGRAM HERE</p>
						<p>This gets biased by the point count and I didn't even scale it by edge lengths, but it's worth a try anyway.</p>
						<h4>Option 2: Proximity</h4>
						<p>If we have a disconnected point cloud, we can weigh each point by its distance from the current point.</p>
						<p>For example, TODO: ADD DIAGRAM HERE</p>
						<p>I thought it'd would work better since edge lengths won't affect it, but it still gets biased by clusters of points with similar distances.</p>
						<p>Anyway, back on track. Let's jump to the most advanced filters I know!</p>
						<h2>Method 3: Biquad filters</h2>
						<p>Biquad filters are extremely popular for music and sound design. They're used for most digital equalizers, so when you boost the bass or cut the treble, you're likely using a biquad filter.</p>
						<p>It gives you full control over the frequency response, so you can make precise changes without affecting other frequencies.</p>
						<p class="mb-2">
							<b>Time Domain</b>
						</p>
						<div>
							<canvas id="biquadCanvas" width="720" height="256" style="cursor: pointer;"></canvas>
						</div>
						<p class="mb-2">
							<b>Frequency Domain</b>
						</p>
						<div class="mb-1">
							<canvas id="biquadCanvas2" width="720" height="256" style="cursor: pointer;"></canvas>
						</div>
						<div class="mb-2">
							<button id="addFilter" class="btn btn-primary me-3">Add filter</button>
							<input id="useDecibels" type="checkbox" checked>
							<label for="useDecibels">Decibel Scale</label>
						</div>
						<div id="filterList"></div>
						<script>
						(function(){
							// Scale down amplitude so -36dB fits on canvas
							const dbScale = 36;
							// Scale down waveform so full amplitude fits on canvas
							const ampScale = 0.3;
							
							const addFilterElem = document.getElementById("addFilter");
							const filterListElem = document.getElementById("filterList");
							let filters = [];
							
							const canv = document.getElementById("biquadCanvas");
							const ctx = canv.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv);
							
							const useDecibelsToggle = document.getElementById("useDecibels");
							let useDecibels = useDecibelsToggle.checked;
							
							const numSamples = Math.floor(canv.width * 0.5);
							const sampleRate = numSamples;
							
							// We can't measure anything above half the sample rate
							const nyquist = Math.floor(sampleRate * 0.5);
							
							// Storage for time domain waveform
							const timeBefore = new Float32Array(numSamples); // Before filtering
							const timeAfter = new Float32Array(numSamples); // After filtering
							
							// Storage for frequency response of all filters
							const freqResponse = new Float32Array(numSamples);
							
							// Storage for frequency domain magnitudes
							const freqBefore = new Float32Array(nyquist); // Before filtering
							const freqAfter = new Float32Array(nyquist); // After filtering

							// Waves complete a cycle after PI * sampleRate (nyquist * 2)
							for (let i = 0; i < numSamples; ++i) {
								const factor = i / numSamples;
								const lowFreq = Math.sin(factor * Math.PI * nyquist * 0.1);
								const noiseAmount = Math.cos(factor * 15) + 1;
								const rand = Math.random() - 0.5;
								timeBefore[i] = lowFreq * 0.5 + rand * noiseAmount;
							}		
							
							function getCoefficients(type, freq, Q, dbGain) {
								const A = Math.pow(10, dbGain / 40);
								const omega = 2 * Math.PI * freq / sampleRate;
								const sn = Math.sin(omega);
								const cs = Math.cos(omega);

								// Using Q alpha to make it easier to visualize
								const alpha = sn / (2 * Q);
								const beta = Math.sqrt(A + A);
								
								// From "Simple implementation of Biquad filters" by Tom St Denis
								let a0, a1, a2, b0, b1, b2;
								switch (type) {
								case 0: // Regular lowpass
								case 7: // Butterworth lowpass
									b0 = (1 - cs) * 0.5;
									b1 = 1 - cs;
									b2 = (1 - cs) * 0.5;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 1: // Regular lowpass
								case 8: // Butterworth lowpass
									b0 = (1 + cs) * 0.5;
									b1 = -(1 + cs);
									b2 = (1 + cs) * 0.5;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 2: // Regular lowpass
								case 9: // Butterworth lowpass
									b0 = alpha;
									b1 = 0;
									b2 = -alpha;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 3:
									// Notch
									b0 = 1;
									b1 = -2 * cs;
									b2 = 1;
									a0 = 1 + alpha;
									a1 = -2 * cs;
									a2 = 1 - alpha;
									break;
								case 4:
									// Peaking
									b0 = 1 + (alpha * A);
									b1 = -2 * cs;
									b2 = 1 - (alpha * A);
									a0 = 1 + (alpha / A);
									a1 = -2 * cs;
									a2 = 1 - (alpha / A);
									break;
								case 5:
									// Low shelf
									b0 = A * ((A + 1) - (A - 1) * cs + beta * sn);
									b1 = 2 * A * ((A - 1) - (A + 1) * cs);
									b2 = A * ((A + 1) - (A - 1) * cs - beta * sn);
									a0 = (A + 1) + (A - 1) * cs + beta * sn;
									a1 = -2 * ((A - 1) + (A + 1) * cs);
									a2 = (A + 1) + (A - 1) * cs - beta * sn;
									break;
								case 6:
									// High shelf
									b0 = A * ((A + 1) + (A - 1) * cs + beta * sn);
									b1 = -2 * A * ((A - 1) + (A + 1) * cs);
									b2 = A * ((A + 1) + (A - 1) * cs - beta * sn);
									a0 = (A + 1) - (A - 1) * cs + beta * sn;
									a1 = 2 * ((A - 1) - (A + 1) * cs);
									a2 = (A + 1) - (A - 1) * cs - beta * sn;
									break;
								}
								
								// The most important coefficients
								const c0 = b0 / a0;
								const c1 = b1 / a0;
								const c2 = b2 / a0;
								const c3 = a1 / a0;
								const c4 = a2 / a0;
								
								return {
									// Coefficients used to display the frequency response
									"a0": a0, "a1": a1, "a2": a2,
									"b0": b0, "b1": b1, "b2": b2,
									// Coefficients used for actual filtering
									"c0": c0, "c1": c1, "c2": c2, "c3": c3, "c4": c4
								};
							}

							// Discrete fourier transform from https://www.youtube.com/watch?v=ITnPS8HGqLo
							function updateDFT(data) {
								for (let k = 0; k < data.length; ++k) {
									let real = 0;
									let imag = 0;
									for (let n = 0; n < timeBefore.length; ++n) {
										const phase = (2 * Math.PI * k * n) / timeBefore.length;
										real += Math.cos(phase) * timeBefore[n];
										imag -= Math.sin(phase) * timeBefore[n];
									}
									data[k] = Math.sqrt(real * real + imag * imag) / data.length;
								}
							}

							function updateTimeResponse() {
								// Use the original signal when no filters are active
								if (filters.length <= 0) {
									timeAfter.set(timeBefore);
									return;
								}
							
								for (let i = 0; i < filters.length; ++i) {
									const arr = i === 0 ? timeBefore : timeAfter;
									const co = filters[i].coefficients;
									let x1 = x2 = y1 = y2 = 0;
									
									for (let j = 0; j < arr.length; ++j) {
										// Apply the filter
										const sample = arr[j];
										const result = co.c0 * sample + co.c1 * x1 + co.c2 * x2 - co.c3 * y1 - co.c4 * y2;
										
										// Shift x1 to x2, sample to x1
										x2 = x1;
										x1 = sample;
										
										// Shift y1 to y2, result to y1
										y2 = y1;
										y1 = result;

										timeAfter[j] = result;
									}
								}
							}
							
							// From https://www.desmos.com/calculator/m1m7rhdpda
							function getFreqResponse(co, pos) {
								const fa = (co.b0 + co.b1 + co.b2) * 0.5;
								const fb = (co.a0 + co.a1 + co.a2) * 0.5;
								const fc = fa * fa - pos * (4 * co.b0 * co.b2 * (1 - pos) + co.b1 * (co.b0 + co.b2));
								const fd = fb * fb - pos * (4 * co.a0 * co.a2 * (1 - pos) + co.a1 * (co.a0 + co.a2));
								return Math.sqrt(fc / fd);
							}
							
							// From https://www.earlevel.com/main/2016/09/29/cascading-filters/
							function getButterworthQs(order) {
								const Q = [];
								const poleInc = Math.PI / order;
								let firstAngle = poleInc;
								if (order % 2 == 0) {
									firstAngle *= 0.5;
								} else {
									Q.push(0.5);
								}
								
								const pairs = Math.floor(order * 0.5);
								for (let i = 0; i < pairs; i++) {
									Q.push(1 / (2 * Math.cos(firstAngle + i * poleInc)));
								}
								return Q;
							}
							
							function updateFreqResponse() {
								for (let i = 0; i < freqResponse.length; ++i) {
									let pos = Math.sin(Math.PI * i / freqResponse.length * 0.5);
									pos *= pos;
									
									// Apply each filter in series, multiply all magnitudes together
									freqResponse[i] = 1;
									for (let j = 0; j < filters.length; ++j) {
										const co = filters[j].coefficients;
										freqResponse[i] *= getFreqResponse(co, pos);
									}
								}

								// Update frequency spectrum
								for (let i = 0; i < freqAfter.length; ++i) {
									const nearest = Math.floor(i / freqAfter.length * freqResponse.length);
									freqAfter[i] = freqBefore[i] * freqResponse[nearest];
								}
							}
							
							function drawTime() {
								drawBackground(canv, ctx);
								
								ctx.lineWidth = 1.5;
								ctx.strokeStyle = "#707070";
								
								// Draw middle line
								let yPos = 0.5 * canv.height;
								drawLine(canv, ctx, 0, yPos, canv.width, yPos);
								
								ctx.strokeStyle = "#FF0000";
								// Draw clipping top line
								yPos = (0.5 - ampScale) * canv.height;
								drawLine(canv, ctx, 0, yPos, canv.width, yPos);
								
								// Draw clipping bottom line
								yPos = (0.5 + ampScale) * canv.height;
								drawLine(canv, ctx, 0, yPos, canv.width, yPos);
								
								ctx.strokeStyle = "#808080";
								drawData(canv, ctx, timeBefore, ampScale);
								
								ctx.strokeStyle = "white";
								drawData(canv, ctx, timeAfter, ampScale);
							}
							
							const canv2 = document.getElementById("biquadCanvas2");
							const ctx2 = canv2.getContext("2d", { alpha: false });
							resizeCanvasWidth(canv2);
							
							function drawMagnitudes(data) {
								ctx2.beginPath();
								ctx2.moveTo(0, canv2.height);
								for (let i = 0; i < data.length; ++i) {
									if (useDecibels) {
										yPos = canv2.height * 0.5 - (gainTodB(data[i]) / dbScale * 0.5) * canv2.height;
									} else {
										yPos = canv2.height - data[i] * canv2.height * 0.9;
									}
									ctx2.lineTo(i / (data.length - 1) * canv2.width, yPos);
								}
								ctx2.lineTo(canv2.width, canv2.height);
								ctx2.fill();
							}
							
							function drawFreq() {
								drawBackground(canv2, ctx2);
								
								// Draw volume divisions
								let yPos;
								ctx2.lineWidth = 1.5;
								ctx2.strokeStyle = "#707070";
								for (let i = 0; i <= 1; i += 0.1) {
									if (useDecibels) {
										yPos = canv2.height * 0.5 - (gainTodB(i) / dbScale * 0.5) * canv2.height;
									} else {
										yPos = canv2.height - i * canv2.height * 0.5;
									}
									drawLine(canv2, ctx2, 0, yPos, canv2.width, yPos);
								}
								
								// Draw clipping line
								ctx2.strokeStyle = "#FF0000";
								yPos = canv2.height * 0.5;
								drawLine(canv2, ctx2, 0, yPos, canv2.width, yPos);
								
								// Draw magnitudes before filtering
								ctx2.fillStyle = "#808080";
								drawMagnitudes(freqBefore);
								
								// Draw magnitudes after filtering
								ctx2.fillStyle = "#EEEEEE";
								drawMagnitudes(freqAfter);
								
								// Draw filter frequency response
								ctx2.strokeStyle = "#FFFF00";
								ctx2.beginPath();
								for (let i = 0; i < freqResponse.length; ++i) {
									if (useDecibels) {
										yPos = canv2.height * 0.5 - (gainTodB(freqResponse[i]) / dbScale * 0.5) * canv2.height;
									} else {
										yPos = canv2.height - freqResponse[i] * canv2.height * 0.5;
									}
									ctx2.lineTo(i / (freqResponse.length - 1) * canv2.width, yPos);
								}
								ctx2.stroke();
							}
							
							// Disable parameters which aren't used by certain filter types
							function disableElems(filter) {
								filter.elems.Q.style.display = filter.type > 4 ? "none" : "block";
								filter.elems.dbGain.style.display = (filter.type >= 4 && filter.type <= 6) ? "block" : "none";
								filter.elems.order.style.display = filter.type > 6 ? "block" : "none";
							}
							
							function updateCoefficients(filter) {
								filter.coefficients = getCoefficients(filter.type, filter.freq, filter.Q, filter.dbGain);
							}
							
							const filterOptions = [
								"Low Pass",
								"High Pass",
								"Band Pass",
								"Notch",
								"Peaking",
								"Low Shelf",
								"High Shelf",
								"Low Pass (Butterworth)",
								"High Pass (Butterworth)",
								"Band Pass (Butterworth)",
							];
							
							function addSelect(elem, text, filter, key, options) {
								const div = document.createElement("div");
								filter.elems.type = div;
								elem.appendChild(div);
								
								const label = document.createElement("label");
								label.textContent = text;
								div.appendChild(label);
								
								const typeSelect = document.createElement("select");
								for (let i = 0; i < options.length; ++i) {
									const option = document.createElement("option");
									option.text = options[i];
									option.value = i;
									typeSelect.add(option);
								}
								typeSelect.addEventListener("change", function(e) {
									filter[key] = parseInt(e.target.value);
									disableElems(filter);
									updateCoefficients(filter);
									updateTimeResponse();
									updateFreqResponse();
									drawTime();
									drawFreq();
								});
								div.appendChild(typeSelect);
							}
							
							function addSlider(elem, text, min, max, step, filter, key, units) {
								const div = document.createElement("div");
								filter.elems[key] = div;
								elem.appendChild(div);
								
								const label = document.createElement("label");
								label.textContent = text;
								div.appendChild(label);
								
								const value = document.createElement("span");
								value.textContent = filter[key];
								label.appendChild(value);
								
								if (units) {
									const unit = document.createElement("span");
									unit.textContent = units;
									label.appendChild(unit);
								}
								
								const slider = document.createElement("input");
								slider.type = "range";
								slider.min = min;
								slider.max = max;
								slider.value = filter[key];
								slider.step = step;
								slider.addEventListener("input", function(e) {
									value.textContent = e.target.value;
									filter[key] = e.target.value;
									updateCoefficients(filter);
									updateTimeResponse();
									updateFreqResponse();
									drawTime();
									drawFreq();
								});
								div.appendChild(slider);
							}
							
							function addFilter() {
								const filter = {
									"type": 0,
									"order": 4,
									"freq": Math.floor(nyquist * 0.25),
									"Q": 0.707,
									"dbGain": 3,
									"elems": {}
								};

								// Add new element
								const elem = document.createElement("div");
								elem.className = "biquad-filter position-relative d-flex flex-column flex-lg-row text-white rounded mb-2";
								filterListElem.appendChild(elem);
								
								// Add element contents
								addSelect(elem, "Type", filter, "type", filterOptions);
								addSlider(elem, "Frequency: ", 0, nyquist, 1, filter, "freq", " Hz");
								
								// Low pass, high pass, band pass, notch and peaking only
								addSlider(elem, "Q: ", 0, 8, 0.001, filter, "Q");
								
								// Peaking, high shelf and low shelf only
								addSlider(elem, "Gain: ", -dbScale, dbScale, 0.1, filter, "dbGain", " dB");
								
								// Butterworth only
								addSlider(elem, "Order: ", 2, 32, 2, filter, "order");
								
								disableElems(filter);
								updateCoefficients(filter);
								
								// Add delete button
								const close = document.createElement("button");
								close.className = "position-absolute end-0 top-0 mt-2 me-2 btn-close btn-close-white";
								close.addEventListener("click", function(e) {
									elem.remove();
									const index = filters.indexOf(filter);
									if (index >= 0) {
										filters.splice(index, 1);
									}
									updateTimeResponse();
									updateFreqResponse();
									drawTime();
									drawFreq();
								});
								elem.appendChild(close);

								// Add new entry
								filters.push(filter);

								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							}

							canv.addEventListener("click", function(e) {
								mouseClickData(e, canv, timeBefore, ampScale);
								
								updateDFT(freqBefore);
								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							});
							
							canv.addEventListener("mousemove", function(e) {
								if (e.which !== 1) return;
								
								mouseMoveData(e, canv, timeBefore, ampScale);
								
								updateDFT(freqBefore);
								updateTimeResponse();
								updateFreqResponse();
								drawTime();
								drawFreq();
							});
							
							useDecibelsToggle.addEventListener("input", function(e) {
								useDecibels = e.target.checked;
								drawFreq();
							});
							
							addFilterElem.addEventListener("click", addFilter);

							updateDFT(freqBefore);
							addFilter();
						})();
						</script>
						<p>TODO: finish this</p>
						<p>
							<a href="./hips/smoothing/biquad_equalizer.hipnc?raw=true" target="_blank">Download the HIP file!</a>
						</p>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>
